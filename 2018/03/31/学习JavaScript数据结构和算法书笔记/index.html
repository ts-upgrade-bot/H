<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="数据结构,"><meta name="description" content="买了一本学习 JavaScript 数据结构与算法书，记录一下笔记。"><meta name="keywords" content="数据结构"><meta property="og:type" content="article"><meta property="og:title" content="学习JavaScript数据结构和算法书笔记"><meta property="og:url" content="https://github.com/HiMrHu/H.git/2018/03/31/学习JavaScript数据结构和算法书笔记/index.html"><meta property="og:site_name" content="胡先生"><meta property="og:description" content="买了一本学习 JavaScript 数据结构与算法书，记录一下笔记。"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2020-05-04T05:06:36.935Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="学习JavaScript数据结构和算法书笔记"><meta name="twitter:description" content="买了一本学习 JavaScript 数据结构与算法书，记录一下笔记。"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://github.com/HiMrHu/H.git/2018/03/31/学习JavaScript数据结构和算法书笔记/"><title>学习JavaScript数据结构和算法书笔记 | 胡先生</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">胡先生</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://github.com/HiMrHu/H.git/2018/03/31/学习JavaScript数据结构和算法书笔记/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="H"><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="胡先生"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">学习JavaScript数据结构和算法书笔记</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-31T17:04:01+00:00">2018-03-31</time></span></div></header><div class="post-body" itemprop="articleBody"><p>买了一本学习 JavaScript 数据结构与算法书，记录一下笔记。</p><a id="more"></a><blockquote><p>为什么买一本 JavaScript 的书呢，其实因为 C 语言的有点难，想从这本书里面学到点东西，然后学习 c 语言版本的数据结构不是那么难，而且想知道在 JavaScript 中如何运用到数据结构和算法里面的知识，毕竟在很久一段时间 JavaScript 都是自己的吃饭工具。数据结构和算法的目的是为了搞笑解决常见问题，并且对日后的代码质量起比较大的作用</p></blockquote><h1 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量保存的数据可以在需要时进行设置，更新或者提取。(基本每一门具备图灵能力的语言都是右变量的)。<br>在 JavaScript 中基本数据类型有一下几种：</p><p><code>Number</code>数字<br><code>String</code>字符串<br><code>Boolean</code>布尔<br><code>Function</code>函数<br><code>Object</code>对象<br><code>Symbol</code>新增表示唯一的</p><p>当然还有其他类型，上面是六种 JavaScript 基本数据类型</p><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>JavaScript 变量作用域就两种一种全局一种局部</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>这部分也比较简单</p><p>常用的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">算数操作符：+ - * <span class="regexp">/ %(取余) ++ --</span></span><br><span class="line"><span class="regexp">赋值操作符：= += -= *= /</span>= %=(余等)</span><br><span class="line">比较操作符：== === != &gt; &gt;= &lt; &lt;=</span><br><span class="line">逻辑操作符：&amp;&amp;(与) || (或) !(非)</span><br><span class="line">位运算：&amp; 按位与 | 按位或 ^按位异或 ～按位非 &lt;&lt;左移 &gt;&gt;右移 <span class="comment">// 这一行都是二进制数据操作，有点抽象，不是很好理解，我就记住了一个～</span></span><br><span class="line">一元操作符：<span class="keyword">delete</span> 删除一个对象属性或者从数组中删除一个键值</span><br><span class="line"><span class="keyword">typeof</span>：<span class="keyword">typeof</span>操作符可以返回一个变量、字符串、关键词或对象的类型</span><br><span class="line"><span class="keyword">void</span>：<span class="keyword">void</span>运算符表明一个运算没有返回值，他的返回值是 <span class="literal">undefined</span> 我在第三方库中见过用<span class="keyword">void</span>取得原始<span class="literal">undefined</span>值的操作。</span><br><span class="line"><span class="keyword">in</span>：<span class="keyword">in</span> 操作符如果所指定的属性确实存在所指定的对象中会返回<span class="literal">true</span></span><br><span class="line"><span class="keyword">instanceof</span>：如果判断的类型确实是指定的类型则返回<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">运算符优先级：太长了优先级最高的是. []这两个，运算级最低的是 ，</span><br></pre></td></tr></table></figure><h2 id="结构控制"><a href="#结构控制" class="headerlink" title="结构控制"></a>结构控制</h2><p>条件语句：</p><pre><code>if else</code></pre><p>循环</p><pre><code>for
white
do white</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是 JavaScript 的一等公民，函数声明调用传参，还有匿名函数，函数表达式，立即执行函数等等。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>创建对象两种方式：</p><pre><code>const obj = new Object()
const obj = {}</code></pre><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>在面向对象编程中，对象是一个类的实例（JavaScript 没有类，是基于原型的）</p><p>声明一个类来表示一本书</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Book</span>(<span class="params">title, pages, isbn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">    <span class="keyword">this</span>.pages = pages;</span><br><span class="line">    <span class="keyword">this</span>.isbn = isbn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">es6 <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class">// <span class="title">class</span>不会提升，在严格模式下运行，构造函数可选。</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(title, pages, isbn)&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.pages = pages;</span><br><span class="line">        <span class="keyword">this</span>.isbn = isbn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> book = <span class="keyword">new</span> Book(<span class="string">'H'</span>, <span class="number">200</span>, <span class="number">2018</span>);</span><br><span class="line">这样就生成一个实例</span><br><span class="line"></span><br><span class="line">这里这个<span class="keyword">new</span> 运算符算一个重点</span><br><span class="line"></span><br><span class="line">当<span class="keyword">new</span> Book()执行时候，会发生下面这些事</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 一个继承自Book.prototype 的新对象被创建</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 使用指定的参数调用构造函数Book， 并且将<span class="keyword">this</span>绑定到新创建的对象，<span class="keyword">new</span> Book等同于 <span class="keyword">new</span> Book() 也就是没带参数</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 由构造函数返回的对象就是<span class="keyword">new</span>表达式的结果，如果构造函数没有显示返回一个对象，则使用步骤<span class="number">1</span>创建的对象（一般情况下，构造函数不返回值，但是可以主动选择返回对象，用来覆盖正常对象创建的结果）， 这个<span class="keyword">new</span>值得单独拿出来学习。</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><blockquote><p>数组是最简单的内存数据结构</p></blockquote><p>数组储存一系列同一种数据类型的值，但是 JavaScript 中数组可以储存任意类型的值，但是这样使用数组并不是良好的习惯。</p><p>数组的声明：</p><pre><code>const arr = new Array()
const arr = new Array(1,2,3,4,5,6,7)
const arr = []</code></pre><h2 id="添加删除数组元素"><a href="#添加删除数组元素" class="headerlink" title="添加删除数组元素"></a>添加删除数组元素</h2><pre><code>arr.push(8) // 添加到数组最后
arr.pop() // 删除最后一个元素
arr.unshift(0) // 添加到数组最头部
arr.shift() // 删除数组第一个元素
arr.splice() // 用来删除现有元素或者添加新元素来更改数组内容</code></pre><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>就数组里面套数组<br>[[2][3][4][5]] // 这种</p><h2 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h2><pre><code>arr.concat(arr1)
[...arr,arr1]</code></pre><h2 id="数组迭代"><a href="#数组迭代" class="headerlink" title="数组迭代"></a>数组迭代</h2><pre><code>forEach 、 for of 、 map 、every 、some 等方法</code></pre><h2 id="搜索和排序"><a href="#搜索和排序" class="headerlink" title="搜索和排序"></a>搜索和排序</h2><p>sort() 方法，可以根据参数函数对数组进行排序，核心在于排序函数怎么用。V8 引擎对 sort 方法执行两种排序元素小于十个使用插入排序，大于十个使用快速排序。</p><p>搜索：indexOf 来查找对应元素的下标。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈是一种遵从先进后出原则的有序集合，新添加或待删除的元素都保存在栈的末尾，称作栈顶，另一端叫做栈底，在栈里，新元素都靠近栈顶，旧元素都接近栈底。</p><h2 id="栈的创建"><a href="#栈的创建" class="headerlink" title="栈的创建"></a>栈的创建</h2><p>创建一个类来表示栈，先声明一个类</p><pre><code>function Stack(){// 各种属性和方法的声明}</code></pre><p>首先需要一种数据结构里保存数据结构里的元素，这里使用数组</p><pre><code>cosnt items = []</code></pre><p>接下来声明栈的一些方法</p><p>push：添加一个或者几个元素到栈顶<br>pop：移除栈顶部的元素，同时返回移除的元素<br>peek：返回栈顶部的元素，不对栈做任何修改<br>isEmpty：如果栈里面没有元素就返回 true，否则返回 false<br>clear：移除栈里面的所有元素<br>size：返回栈里的元素个数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="comment">// 声明一个数组保存栈里的元素</span></span><br><span class="line">        <span class="keyword">this</span>.items = [];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 向栈里添加新的元素</span></span><br><span class="line">    push (element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除栈中的元素，遵循先进后出的原则，先出的就是最后元素</span></span><br><span class="line">    pop () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.pop()</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 返回栈顶部的元素</span></span><br><span class="line">    peek () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length <span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    isEmpty () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回栈的长度</span></span><br><span class="line">    size () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除栈</span></span><br><span class="line">    clear () &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = []</span><br><span class="line">    &#125;</span><br><span class="line">    print() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.items)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成实例</span></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line"><span class="comment">// 向栈内添加元素</span></span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stack.peek()) <span class="comment">// 8因为8是最后进所以应该最先返回</span></span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">11</span>)</span><br><span class="line"><span class="built_in">console</span>.log(stack.size()) <span class="comment">// 返回栈的长度 3</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty()) <span class="comment">// 查看栈是否为空</span></span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">stack.pop() <span class="comment">// 删除11</span></span><br><span class="line">stack.pop() <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stack.size()) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">stack.print() <span class="comment">// [5, 8]</span></span><br><span class="line"></span><br><span class="line">下面用构造函数写一下</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items = []</span><br><span class="line">    <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">        items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[items.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length === <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        items = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(items)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">接下来就一样了</span><br></pre></td></tr></table></figure><h2 id="例子十进制到二进制的转换"><a href="#例子十进制到二进制的转换" class="headerlink" title="例子十进制到二进制的转换"></a>例子十进制到二进制的转换</h2><p>要把十进制转换成二进制可以将十进制数字除以二（二进制就是满二进一）直到结果为 0 位置</p><p>那么使用上面的栈来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divideBy2</span>(<span class="params">decNumber</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> remStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">let</span> rem, binaryString = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (decNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        rem = <span class="built_in">Math</span>.floor(decNumber % <span class="number">2</span>); <span class="comment">// 向下取整去到余数</span></span><br><span class="line">        remStack.push(rem); <span class="comment">// 入栈</span></span><br><span class="line">        decNumber = <span class="built_in">Math</span>.floor(decNumber / <span class="number">2</span>); <span class="comment">// 修改值再循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!remStack.isEmpty()) &#123;</span><br><span class="line">        binaryString += remStack.pop().toString() <span class="comment">// 栈不为空那么就从栈中依次去出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binaryString; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这段算法可以修改成十进制转换任意进制</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseConverter</span>(<span class="params">decNumber, base</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> remStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">let</span> rem, baseString = <span class="string">''</span>, digits = <span class="string">'0123456789ABCDEF'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(decNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        rem = <span class="built_in">Math</span>.floor(decNumber % base)</span><br><span class="line">        remStack.push(rem);</span><br><span class="line">        decNumber = <span class="built_in">Math</span>.floor(decNumber / base)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!remStack.isEmpty())&#123;</span><br><span class="line">        baseString += digits[remStack.pop()]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> baseString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>,<span class="number">2</span>) <span class="comment">// 1100100</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>,<span class="number">10</span>) <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>,<span class="number">8</span>) <span class="comment">// 144</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>,<span class="number">16</span>) <span class="comment">// 64</span></span><br></pre></td></tr></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是遵循先进先出原则的一组有序列，列队在尾部添加新元素，并从顶部移除元素，最新添加的元素必须在队列为末尾。</p><p>在现实中最常见的例子就是排队。</p><h2 id="创建列队"><a href="#创建列队" class="headerlink" title="创建列队"></a>创建列队</h2><p>创建自己的类来表示一个队列和上面的例子非常相似知识添加移除元素原则不同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="comment">// 声明一个数组保存队列里的元素</span></span><br><span class="line">        <span class="keyword">this</span>.items = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加元素到队列末尾</span></span><br><span class="line">    enqueue (element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 移除并返回队列第一个元素</span></span><br><span class="line">    dequeue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.shift()</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 返回队列第一个元素</span></span><br><span class="line">    front() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//  判断元素是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//  清空队列</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = []</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//  返回队列元素长度</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> items.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印队列</span></span><br><span class="line">    print() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.items)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用队列"><a href="#使用队列" class="headerlink" title="使用队列"></a>使用队列</h2><p>上面创建了个队列的类，现在生成一个对象，就可以使用它了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> Queue()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(queue.isEmpty()) <span class="comment">// 返回true，因为队列为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//现在添加几个元素</span></span><br><span class="line"></span><br><span class="line">queue.enqueue(<span class="string">'john'</span>)</span><br><span class="line">queue.enqueue(<span class="string">'jack'</span>)</span><br><span class="line">queue.enqueue(<span class="string">'camila'</span>)</span><br><span class="line"></span><br><span class="line">queue.print() <span class="comment">// ["john", "jack", "camila"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(queue.size()) <span class="comment">// 输出3</span></span><br><span class="line"><span class="built_in">console</span>.log(queue.isEmpty()) <span class="comment">//false 队列不为空</span></span><br><span class="line"></span><br><span class="line">queue.dequeue()</span><br><span class="line">queue.dequeue()</span><br><span class="line">queue.print() <span class="comment">// ["camila"] 前面的两个元素已经被删除掉了</span></span><br><span class="line"><span class="comment">// 向队列中添加三个元素</span></span><br></pre></td></tr></table></figure><h2 id="队列优先"><a href="#队列优先" class="headerlink" title="队列优先"></a>队列优先</h2><p>列队大量应用在计算机科学和生活中，这里可以修改上面的列队，让他称为一个优先列队，元素的添加和移除是基于优先级的，现实中的例子，比如医院中的重症患者和普通患者，优先级别是不同的。</p><p>要实现一个优先列队，有两种选项：设置优先级，然后在正确的位置添加元素，或者用入列操作添加元素，然后按照优先级移除他们。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PriorityQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> items = [];</span><br><span class="line">   <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.items)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">QueueElenent</span> (<span class="params">element, priority</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">QueueElement</span> (<span class="params">element, priority</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.element = element;</span><br><span class="line">  <span class="keyword">this</span>.priority = priority;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span>(<span class="params">element, priority</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> queueElement = <span class="keyword">new</span> QueueElement(element, priority);</span><br><span class="line">  <span class="keyword">let</span> added = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;items.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (queueElement.priority &lt; items[i].priority)&#123;</span><br><span class="line">      items.splice(i,<span class="number">0</span>,queueElement);</span><br><span class="line">      added = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!added)&#123;</span><br><span class="line">    items.push(queueElement);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;items.length; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;items[i].element&#125;</span> - <span class="subst">$&#123;items[i].priority&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> PriorityQueue()</span><br><span class="line"></span><br><span class="line">queue.enqueue(<span class="string">'john'</span>,<span class="number">2</span>)</span><br><span class="line">queue.enqueue(<span class="string">'jack'</span>,<span class="number">1</span>)</span><br><span class="line">queue.enqueue(<span class="string">'camila'</span>,<span class="number">1</span>)</span><br><span class="line">queue.print()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里就是就是增加了一个QueueElement类，这个元素包含了要添加列队的元素，他可以是任意类型的，还有本身的优先级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果列队为空，可以直接插入，否则就需要比较这个元素和其他列队元素的优先级，当找到一个优先级值更大（值越大优先级越底）就把元素插入在他之前</span></span><br></pre></td></tr></table></figure><h2 id="循环队列–击鼓传花"><a href="#循环队列–击鼓传花" class="headerlink" title="循环队列–击鼓传花"></a>循环队列–击鼓传花</h2><p>另一种队列的实现就是<code>循环列队</code>，列队循环的例子就是击鼓传花游戏，在游戏中，若干小孩围城一个圆圈，把花尽快传递给旁边的人，某一时刻传花停止，这个时候花在谁手中，谁就退出圆圈，结束游戏，重复这个过程，直到只剩一个小孩。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = [];</span><br><span class="line">        &#125;</span><br><span class="line">    enqueue (element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">    dequeue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    front() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = []</span><br><span class="line">    &#125;</span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length;</span><br><span class="line">    &#125;</span><br><span class="line">    print() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.items)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hotPotato</span> (<span class="params">nameList, num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nameList.length; i++) &#123;</span><br><span class="line">        queue.enqueue(nameList[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> eliminated = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            queue.enqueue(queue.dequeue())</span><br><span class="line">        &#125;</span><br><span class="line">        eliminated = queue.dequeue()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"被淘汰"</span>, eliminated)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.dequeue()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> name = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'john'</span>,<span class="string">'jack'</span>,<span class="string">'camila'</span>,<span class="string">'ingrif'</span>,<span class="string">'carl'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name)</span><br><span class="line"><span class="keyword">const</span> winner = hotPotato(name, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">console</span>.log(winner)</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>数组（可以刻称为列表）是一种非常简单的存储数据序列的数据结构。接下来需要学习如何使用链表和动态的数据结构这意味着可以从中任意添加或者移除向，它会按需进行扩容。</p><p>要储存多个元素，数组或者列表可能是最常见的数据结构，这种数据结构非常方便，然而这种结构有一个缺点，在大多数语言中数组的大小是固定的，，从数组中的起点或者中间插入和移除项的成本很高，因为这意味着要移动其他的元素，尽管 JavaScript 中 Array 类方法提供了方法，但是背后的情况是一样的。这种成本有时候的代价是高昂的，不可以接受的。</p><p>链表储存有序的元素集合，但是不同于数组，链表中的元素在内存中并不是连续放置的，每个元素由一个储存元素本身的节点和一个指向下一个元素的引用（c 语言中的指针）组成，相对于数组，链表的一个好处在于，添加或者移除元素的时候不需要移动其他的元素，然而，链表需要使用指针，因此实现链表时，需要额外注意，数组的另一个细节是可以<code>直接访问任何位置的元素</code>，然而想访问链表中的一个元素，<code>需要从七点开始迭代链表直到找到位置</code>。</p><h2 id="创建一个链表"><a href="#创建一个链表" class="headerlink" title="创建一个链表"></a>创建一个链表</h2><p>使用 JavaScript 实现一个链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 储存列表项的数量length属性</span></span><br><span class="line">        <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 储存第一个节点的引用</span></span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向链表尾部添加一个新的元素 （实现第一步）</span></span><br><span class="line">    append (element) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">      <span class="keyword">let</span> current;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.head === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果链表的第一个元素为空</span></span><br><span class="line">        <span class="keyword">this</span>.head = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果链表不为空</span></span><br><span class="line">        current = <span class="keyword">this</span>.head; <span class="comment">// 储存链表第一个元素</span></span><br><span class="line">        <span class="keyword">while</span> (current.next) &#123; <span class="comment">// 迭代链表直到找到链表的结尾</span></span><br><span class="line">          current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = node;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.length++; <span class="comment">// 更新链表长度</span></span><br><span class="line">      <span class="comment">// 此时链表的最后一个元素的next会指向空因为Node类预先赋值为noll</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向链表指定位置插入一个新的项</span></span><br><span class="line">    insert (position, element) &#123;&#125;</span><br><span class="line">    <span class="comment">// 从链表的特定位置移除一项</span></span><br><span class="line">    removeAt (position) &#123;&#125;</span><br><span class="line">    <span class="comment">// 从链表中移除一项</span></span><br><span class="line">    remove (element) &#123;&#125;</span><br><span class="line">    <span class="comment">// 返回元素在链表中的索引</span></span><br><span class="line">    indexOf (element) &#123;&#125;</span><br><span class="line">    <span class="comment">// 如果链表中不包含任何元素返回true否则返回false</span></span><br><span class="line">    isEmpty () &#123;&#125;</span><br><span class="line">    <span class="comment">// 返回链表包含的元素个数</span></span><br><span class="line">    size () &#123;&#125;</span><br><span class="line">    <span class="comment">// 由于链表项使用了Node类，就需要重写集成于JavaScript对象默认的toString方法，让他只输出元素的值</span></span><br><span class="line">    toString () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">list.append(<span class="number">15</span>)</span><br><span class="line">list.append(<span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(list) <span class="comment">// 这个时候测试刚刚实现的append方法会在谷歌控制台</span></span><br><span class="line"><span class="comment">// 得到我们的list实例</span></span><br><span class="line"><span class="comment">// 大概长这个样子</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">list = LinkedList &#123;</span></span><br><span class="line"><span class="comment">    head: &#123;</span></span><br><span class="line"><span class="comment">        element: 15,</span></span><br><span class="line"><span class="comment">        next: &#123;</span></span><br><span class="line"><span class="comment">            element: 18,</span></span><br><span class="line"><span class="comment">            next: null</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    length: 2</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 大概就是上面这种结构</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>appemd 方法实现了，接下来实现其他方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 removeAt 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 储存列表项的数量length属性</span></span><br><span class="line">        <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 储存第一个节点的引用</span></span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向链表尾部添加一个新的元素</span></span><br><span class="line">    append (element) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">      <span class="keyword">let</span> current;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.head === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果链表的第一个元素为空</span></span><br><span class="line">        <span class="keyword">this</span>.head = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果链表不为空</span></span><br><span class="line">        current = <span class="keyword">this</span>.head; <span class="comment">// 储存链表第一个元素</span></span><br><span class="line">        <span class="keyword">while</span> (current.next) &#123; <span class="comment">// 迭代链表直到找到链表的结尾</span></span><br><span class="line">          current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = node;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.length++; <span class="comment">// 更新链表长度</span></span><br><span class="line">      <span class="comment">// 此时链表的最后一个元素的next会指向空因为Node类预先赋值为noll</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向链表指定位置插入一个新的项</span></span><br><span class="line">    insert (position, element) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从链表的特定位置移除一项</span></span><br><span class="line">    removeAt (position) &#123;</span><br><span class="line">      <span class="keyword">if</span>(position &gt; <span class="number">-1</span> &amp;&amp; position &lt; <span class="keyword">this</span>.length)&#123; <span class="comment">// 检查是否越界</span></span><br><span class="line">        <span class="comment">// 判断指定位置是大于-1 和小于链表长度</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head, previous, index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果制定项是第一项</span></span><br><span class="line">        <span class="keyword">if</span> (position === <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">this</span>.head = current.next; <span class="comment">// 直接让头指针指向第二位</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">while</span>(index ++ &lt; position) &#123; <span class="comment">// 迭代链表</span></span><br><span class="line">            <span class="comment">// 储存要被删除的前一个元素</span></span><br><span class="line">            previous = current;</span><br><span class="line">            <span class="comment">// 储存要被删除的后一个匀速</span></span><br><span class="line">            current = current.next;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 链接前后，被删除的元素被丢弃在内存中等待垃圾回收。</span></span><br><span class="line">          previous.next = current.next;</span><br><span class="line">          <span class="keyword">this</span>.length --;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从链表中移除一项</span></span><br><span class="line">    remove (element) &#123;&#125;</span><br><span class="line">    <span class="comment">// 返回元素在链表中的索引</span></span><br><span class="line">    indexOf (element) &#123;&#125;</span><br><span class="line">    <span class="comment">// 如果链表中不包含任何元素返回true否则返回false</span></span><br><span class="line">    isEmpty () &#123;&#125;</span><br><span class="line">    <span class="comment">// 返回链表包含的元素个数</span></span><br><span class="line">    size () &#123;&#125;</span><br><span class="line">    <span class="comment">// 由于链表项使用了Node类，就需要重写集成于JavaScript对象默认的toString方法，让他只输出元素的值</span></span><br><span class="line">    toString () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">list.append(<span class="number">10</span>)</span><br><span class="line">list.append(<span class="number">20</span>)</span><br><span class="line">list.append(<span class="number">30</span>)</span><br><span class="line">list.append(<span class="number">40</span>)</span><br><span class="line"><span class="built_in">console</span>.log(list) <span class="comment">// length 4</span></span><br><span class="line">list.removeAt(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(list) <span class="comment">// length 3</span></span><br></pre></td></tr></table></figure><p>实现 insert 方法，任意位置插入一个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 储存列表项的数量length属性</span></span><br><span class="line">        <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 储存第一个节点的引用</span></span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向链表尾部添加一个新的元素</span></span><br><span class="line">    append (element) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">      <span class="keyword">let</span> current;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.head === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果链表的第一个元素为空</span></span><br><span class="line">        <span class="keyword">this</span>.head = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果链表不为空</span></span><br><span class="line">        current = <span class="keyword">this</span>.head; <span class="comment">// 储存链表第一个元素</span></span><br><span class="line">        <span class="keyword">while</span> (current.next) &#123; <span class="comment">// 迭代链表直到找到链表的结尾</span></span><br><span class="line">          current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = node;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.length++; <span class="comment">// 更新链表长度</span></span><br><span class="line">      <span class="comment">// 此时链表的最后一个元素的next会指向空因为Node类预先赋值为noll</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向链表指定位置插入一个新的项</span></span><br><span class="line">    insert (position, element) &#123;</span><br><span class="line">      <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= <span class="keyword">this</span>.length) &#123; <span class="comment">// 越界检查保证位置合理</span></span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head, previous, index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 在第一个位置添加</span></span><br><span class="line">          node.netx = current; <span class="comment">// 将原有链表添加在他后面</span></span><br><span class="line">          head = node; <span class="comment">// 并将头指向这个元素</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">while</span> (index ++ &lt; position) &#123;</span><br><span class="line">            previous = current;</span><br><span class="line">            current = current.next;</span><br><span class="line">          &#125;</span><br><span class="line">          node.next = current;</span><br><span class="line">          previous.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.length ++</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从链表的特定位置移除一项</span></span><br><span class="line">    removeAt (position) &#123;</span><br><span class="line">      <span class="keyword">if</span>(position &gt; <span class="number">-1</span> &amp;&amp; position &lt; <span class="keyword">this</span>.length)&#123; <span class="comment">// 检查是否越界</span></span><br><span class="line">        <span class="comment">// 判断指定位置是大于-1 和小于链表长度</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head, previous, index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果制定项是第一项</span></span><br><span class="line">        <span class="keyword">if</span> (position === <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">this</span>.head = current.next; <span class="comment">// 直接让头指针指向第二位</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">while</span>(index ++ &lt; position) &#123; <span class="comment">// 迭代链表</span></span><br><span class="line">            <span class="comment">// 储存要被删除的前一个元素</span></span><br><span class="line">            previous = current;</span><br><span class="line">            <span class="comment">// 储存要被删除的后一个匀速</span></span><br><span class="line">            current = current.next;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 链接前后，被删除的元素被丢弃在内存中等待垃圾回收。</span></span><br><span class="line">          previous.next = current.next;</span><br><span class="line">          <span class="keyword">this</span>.length --;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从链表中移除一项</span></span><br><span class="line">    remove (element) &#123;&#125;</span><br><span class="line">    <span class="comment">// 返回元素在链表中的索引</span></span><br><span class="line">    indexOf (element) &#123;&#125;</span><br><span class="line">    <span class="comment">// 如果链表中不包含任何元素返回true否则返回false</span></span><br><span class="line">    isEmpty () &#123;&#125;</span><br><span class="line">    <span class="comment">// 返回链表包含的元素个数</span></span><br><span class="line">    size () &#123;&#125;</span><br><span class="line">    <span class="comment">// 由于链表项使用了Node类，就需要重写集成于JavaScript对象默认的toString方法，让他只输出元素的值</span></span><br><span class="line">    toString () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">list.append(<span class="number">10</span>)</span><br><span class="line">list.append(<span class="number">20</span>)</span><br><span class="line">list.append(<span class="number">30</span>)</span><br><span class="line">list.append(<span class="number">40</span>)</span><br><span class="line"><span class="built_in">console</span>.log(list)</span><br><span class="line">list.removeAt(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(list)</span><br><span class="line">list.insert(<span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.log(list)</span><br></pre></td></tr></table></figure><p>接下来思路差不多了，一口气写完</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 储存列表项的数量length属性</span></span><br><span class="line">        <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 储存第一个节点的引用</span></span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向链表尾部添加一个新的元素</span></span><br><span class="line">    append (element) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">      <span class="keyword">let</span> current;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.head === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果链表的第一个元素为空</span></span><br><span class="line">        <span class="keyword">this</span>.head = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果链表不为空</span></span><br><span class="line">        current = <span class="keyword">this</span>.head; <span class="comment">// 储存链表第一个元素</span></span><br><span class="line">        <span class="keyword">while</span> (current.next) &#123; <span class="comment">// 迭代链表直到找到链表的结尾</span></span><br><span class="line">          current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = node;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.length++; <span class="comment">// 更新链表长度</span></span><br><span class="line">      <span class="comment">// 此时链表的最后一个元素的next会指向空因为Node类预先赋值为noll</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向链表指定位置插入一个新的项</span></span><br><span class="line">    insert (position, element) &#123;</span><br><span class="line">      <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= <span class="keyword">this</span>.length) &#123; <span class="comment">// 越界检查保证位置合理</span></span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head, previous, index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 在第一个位置添加</span></span><br><span class="line">          node.netx = current; <span class="comment">// 将原有链表添加在他后面</span></span><br><span class="line">          head = node; <span class="comment">// 并将头指向这个元素</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">while</span> (index ++ &lt; position) &#123;</span><br><span class="line">            previous = current;</span><br><span class="line">            current = current.next;</span><br><span class="line">          &#125;</span><br><span class="line">          node.next = current;</span><br><span class="line">          previous.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.length ++</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从链表的特定位置移除一项</span></span><br><span class="line">    removeAt (position) &#123;</span><br><span class="line">      <span class="keyword">if</span>(position &gt; <span class="number">-1</span> &amp;&amp; position &lt; <span class="keyword">this</span>.length)&#123; <span class="comment">// 检查是否越界</span></span><br><span class="line">        <span class="comment">// 判断指定位置是大于-1 和小于链表长度</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head, previous, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.head.element; <span class="comment">// 修复删除0返回值不正确</span></span><br><span class="line">        <span class="comment">// 如果制定项是第一项</span></span><br><span class="line">        <span class="keyword">if</span> (position === <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">this</span>.head = current.next; <span class="comment">// 直接让头指针指向第二位</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">while</span>(index ++ &lt; position) &#123; <span class="comment">// 迭代链表</span></span><br><span class="line">            <span class="comment">// 储存要被删除的前一个元素</span></span><br><span class="line">            previous = current;</span><br><span class="line">            <span class="comment">// 储存要被删除的后一个匀速</span></span><br><span class="line">            current = current.next;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 链表前后，被删除的元素被丢弃在内存中等待垃圾回收。</span></span><br><span class="line">          previous.next = current.next;</span><br><span class="line">          <span class="keyword">this</span>.length --;</span><br><span class="line">          <span class="keyword">return</span> current.element</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从链表中移除一项</span></span><br><span class="line">    remove (element) &#123;</span><br><span class="line">      <span class="keyword">const</span> index = <span class="keyword">this</span>.indexOf(element);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回元素在链表中的索引</span></span><br><span class="line">    indexOf (element) &#123;</span><br><span class="line">      <span class="comment">// 如果找到元素就返回index 如果找不到就返回-1</span></span><br><span class="line">      <span class="keyword">let</span> current = <span class="keyword">this</span>.head,index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(current) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element === current.element) &#123;</span><br><span class="line">          <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        index ++;</span><br><span class="line">        current = current.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果链表中不包含任何元素返回true否则返回false</span></span><br><span class="line">    isEmpty () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.length === <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回链表包含的元素个数</span></span><br><span class="line">    size () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.length</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于链表项使用了Node类，就需要重写集成于JavaScript对象默认的toString方法，让他只输出元素的值</span></span><br><span class="line">    toString () &#123;</span><br><span class="line">      <span class="keyword">let</span> current = <span class="keyword">this</span>.head, string = <span class="string">''</span>;</span><br><span class="line">      <span class="keyword">while</span> (current) &#123;</span><br><span class="line">        string += <span class="string">` <span class="subst">$&#123;current.element&#125;</span>`</span>; <span class="comment">// 带点空格好看</span></span><br><span class="line">        current = current.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印链表元素</span></span><br><span class="line">    getHead () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>链表有很多不同的类型，上面的叫做<code>单项链表</code>对应的就有双向链表，在双向链表中，链接是双向的，一个链向下一个链向上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element)&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.preve = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结构改成这个样子</span></span><br></pre></td></tr></table></figure><p>那么大体和上面的例子差不多就不单独举例了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element)&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  insert(position, element)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是否越界</span></span><br><span class="line">     <span class="keyword">if</span>(position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= <span class="keyword">this</span>.length)&#123;</span><br><span class="line">            <span class="keyword">var</span> node = <span class="keyword">new</span> Node(element),</span><br><span class="line">                    current = <span class="keyword">this</span>.head,</span><br><span class="line">                    previous,</span><br><span class="line">                    index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(position === <span class="number">0</span>)&#123; <span class="comment">// 链表为空直接赋值</span></span><br><span class="line">                <span class="keyword">if</span>(!<span class="keyword">this</span>.head)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.head = node;</span><br><span class="line">                    <span class="keyword">this</span>.tail = node;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node.next = current;</span><br><span class="line">                    current.prev = node;</span><br><span class="line">                    <span class="keyword">this</span>.head = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(position === <span class="keyword">this</span>.length)&#123; <span class="comment">// 链表末尾</span></span><br><span class="line">                current = <span class="keyword">this</span>.tail;</span><br><span class="line">                current.next = node;</span><br><span class="line">                node.prev = current;</span><br><span class="line">                <span class="keyword">this</span>.tail = node;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(index++ &lt; position)&#123; <span class="comment">// 查找链表位置插入</span></span><br><span class="line">                    previous = current;</span><br><span class="line">                    current = current.next;</span><br><span class="line">                &#125;</span><br><span class="line">                node.next = current;</span><br><span class="line">                previous.next = node;</span><br><span class="line"></span><br><span class="line">                current.prev = node;</span><br><span class="line">                node.prev = previous;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.length++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  removeAt (position) &#123;</span><br><span class="line">    <span class="keyword">if</span>(position &gt; <span class="number">-1</span> &amp;&amp; position &lt; <span class="keyword">this</span>.length) &#123;</span><br><span class="line">      <span class="keyword">let</span> current = <span class="keyword">this</span>.head, previous, index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是第一项</span></span><br><span class="line">        <span class="keyword">this</span>.head = current.next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === <span class="keyword">this</span>.length <span class="number">-1</span>) &#123;</span><br><span class="line">        current = <span class="keyword">this</span>.tail;</span><br><span class="line">        <span class="keyword">this</span>.tail = current.prev;</span><br><span class="line">        <span class="keyword">this</span>.tail.next = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (index ++ &lt; position) &#123;</span><br><span class="line">          previous = current;</span><br><span class="line">          current - current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        previous.next = current.next;</span><br><span class="line">        current.next.prev = previous;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.length --;</span><br><span class="line">      <span class="keyword">return</span> current.element;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> list = <span class="keyword">new</span> DoublyLinkedList()</span><br><span class="line">list.insert(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(list)</span><br></pre></td></tr></table></figure><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><blockquote><p>集合是一种由无需且唯一（即不能重复）的项组成的，这个数据结构使用了有限集合相同的数学概念。</p></blockquote><p>JavaScript 在 2015 年发布了 ECMAscript2015 即 ES6，其中就包含了 set 类的实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里items使用了对象而不是数组表示集合，但是可以以使用数组</span></span><br><span class="line"><span class="comment">在JavaScript中的对象不允许一个键指向两个不同的属性，这也就保证了</span></span><br><span class="line"><span class="comment">集合里面的元素都是唯一的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>接下来在 class 中添加方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回布尔值</span></span><br><span class="line">    has(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.hasOwnProperty(value);</span><br><span class="line">    &#125;</span><br><span class="line">    add(value) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!<span class="keyword">this</span>.has(value)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items[value] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    remove(value) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.has(value)) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>.items[value]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    clear() &#123;</span><br><span class="line">      <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    size() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.items).length</span><br><span class="line">    &#125;</span><br><span class="line">    values() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.items)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这段代码没什么难度，注释都不需要，思想挺好的，以前都没想到过</span></span><br></pre></td></tr></table></figure><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><p>对于集合可以进行如下操作</p><ol><li><p>并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合</p></li><li><p>交集：对于给定的两个集合， 返回一个包含两个集合中共有的新集合</p></li><li><p>差集：对于给定的两个集合， 返回一个包含所有存在第一个集合并且不存在第二个集合的新集合</p></li><li><p>子集：验证一个给定集合是否是另一个集合的子集</p></li></ol><p>并集：并集的数学概念是集合 A 和 B 的并集</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现set 类的并集方法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetUnion</span> <span class="keyword">extends</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">    union (otherSet) &#123;</span><br><span class="line">        <span class="keyword">const</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="keyword">let</span> values = <span class="keyword">this</span>.values()</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            unionSet.add(values[i])</span><br><span class="line">        &#125;</span><br><span class="line">        values = otherSet.value()</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            unionSet.add(values[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unionSet</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> SetUnion()</span><br><span class="line">setA.add(<span class="number">1</span>)</span><br><span class="line">setA.add(<span class="number">2</span>)</span><br><span class="line">setA.add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> SetUnion()</span><br><span class="line"></span><br><span class="line">setB.add(<span class="number">3</span>)</span><br><span class="line">setB.add(<span class="number">4</span>)</span><br><span class="line">setB.add(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unionAB = setA.union(setB)</span><br><span class="line"><span class="built_in">console</span>.log(unionAB.values())</span><br></pre></td></tr></table></figure><p>交集： 交集的数学概念是集合 A 和集合 B 的交集</p><p>实现以下 Set 类的 intersection 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Intersection</span> <span class="keyword">extends</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">    intersection (otherSet) &#123;</span><br><span class="line">        <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (otherSet.has(values[i]))&#123;</span><br><span class="line">                instersectionSet.add(values[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instersectionSet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Intersection</span> <span class="keyword">extends</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">    intersection (otherSet) &#123;</span><br><span class="line">        <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (otherSet.has(values[i]))&#123;</span><br><span class="line">                intersectionSet.add(values[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersectionSet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> Intersection()</span><br><span class="line">setA.add(<span class="number">1</span>)</span><br><span class="line">setA.add(<span class="number">2</span>)</span><br><span class="line">setA.add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> Intersection()</span><br><span class="line"></span><br><span class="line">setB.add(<span class="number">3</span>)</span><br><span class="line">setB.add(<span class="number">4</span>)</span><br><span class="line">setB.add(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unionAB = setA.intersection(setB)</span><br><span class="line"><span class="built_in">console</span>.log(unionAB.values())<span class="comment">// ['3']</span></span><br></pre></td></tr></table></figure><p>差集：差集的数学概念，集合 A 和集合 B 的差集，表示 A—B</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span> <span class="keyword">extends</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">    difference (otherSet) &#123;</span><br><span class="line">        <span class="keyword">const</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">        <span class="keyword">let</span> values = <span class="keyword">this</span>.values()</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!otherSet.has(values[i]))&#123;</span><br><span class="line">                differenceSet.add(values[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> differenceSet</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> Difference()</span><br><span class="line">setA.add(<span class="number">1</span>)</span><br><span class="line">setA.add(<span class="number">2</span>)</span><br><span class="line">setA.add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> Difference()</span><br><span class="line"></span><br><span class="line">setB.add(<span class="number">3</span>)</span><br><span class="line">setB.add(<span class="number">4</span>)</span><br><span class="line">setB.add(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unionAB = setA.difference(setB)</span><br><span class="line"><span class="built_in">console</span>.log(unionAB.values()) <span class="comment">// ['1','2']</span></span><br></pre></td></tr></table></figure><p>子集：子集的数学概念，集合 A 是集合 B 的子集就是说 B 包含了 A 的所有元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subset</span> <span class="keyword">extends</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">    subset (otherSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size() &gt; otherSet.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!otherSet.has(values[i]))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> Subset()</span><br><span class="line">setA.add(<span class="number">1</span>)</span><br><span class="line">setA.add(<span class="number">2</span>)</span><br><span class="line">setA.add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> Subset()</span><br><span class="line"></span><br><span class="line">setB.add(<span class="number">3</span>)</span><br><span class="line">setB.add(<span class="number">4</span>)</span><br><span class="line">setB.add(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">const</span> setC = <span class="keyword">new</span> Subset()</span><br><span class="line">setA.add(<span class="number">1</span>)</span><br><span class="line">setA.add(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(setC.subset(setA)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="字典和散列表"><a href="#字典和散列表" class="headerlink" title="字典和散列表"></a>字典和散列表</h1><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>集合、字典和散列表可以表示一组互不相同的元素(不重复)的值，在集合中重要的是每个值本身，并把他当做主要元素， 在字典中使用[键，值]的形式储存数据，在散列表中也是一样，但是两种数据的结构实现方式略有不同。</p><h3 id="创建一个字典"><a href="#创建一个字典" class="headerlink" title="创建一个字典"></a>创建一个字典</h3><p>和 set 类似，ES6 也已经实现了 Map 结构，这就是所说的字典结构。<br>实现一个比 Map 简单的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dictionary</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    has (key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.hasOwnProperty(key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> (key, value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    remove (key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.has(key))&#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>.items[key];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> (key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.has(key) ? <span class="keyword">this</span>.items[key] : undefinde</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dictionary = <span class="keyword">new</span> Dictionary()</span><br><span class="line">dictionary.set(<span class="string">'gandalf'</span>,<span class="string">'gandelf@qq.com'</span>)</span><br><span class="line">dictionary.set(<span class="string">'john'</span>,<span class="string">'john@qq.com'</span>)</span><br><span class="line">dictionary.set(<span class="string">'tyrion'</span>,<span class="string">'tyrion@qq.com'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(dictionary)</span><br><span class="line"><span class="comment">// es6的Map数据结构，是真正的值-值，因为普通对象的键只能是字符串，而es6的Map</span></span><br><span class="line"><span class="comment">// 键可以是任何内容，数字啊，字符串啊，甚至dom都可以</span></span><br></pre></td></tr></table></figure><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p><code>散列算法</code>的作用是尽可能快的在数据结构中找到一个值，上面的类中需要找到一个值，需要遍历整个数据结构来找到他，如果使用<code>散列函数</code>就知道值的具体位置，因此能够快速检索到该值，散列函数的作用是给定一个键值，然后返回值在表中的地址。</p><h3 id="创建一个散列表"><a href="#创建一个散列表" class="headerlink" title="创建一个散列表"></a>创建一个散列表</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.table = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 散列函数</span></span><br><span class="line">  liseloseHashCode (key) &#123;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; key.length; i++) &#123;</span><br><span class="line">      hash += key.charCodeAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash % <span class="number">37</span>; <span class="comment">// 为了返回一个比较小的值。</span></span><br><span class="line">  &#125;</span><br><span class="line">  put (key, value) &#123;</span><br><span class="line">    <span class="keyword">const</span> position = <span class="keyword">this</span>.liseloseHashCode(key);</span><br><span class="line">    <span class="keyword">this</span>.table[position] = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> (key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.table[<span class="keyword">this</span>.liseloseHashCode(key)];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remove (key) &#123;</span><br><span class="line">    <span class="keyword">this</span>.table[<span class="keyword">this</span>.liseloseHashCode(key)] = undefinde</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hash = <span class="keyword">new</span> HashTable()</span><br><span class="line">hash.put(<span class="string">'gandalf'</span>,<span class="string">'gandelf@qq.com'</span>)</span><br><span class="line">hash.put(<span class="string">'john'</span>,<span class="string">'john@qq.com'</span>)</span><br><span class="line">hash.put(<span class="string">'tyrion'</span>,<span class="string">'tyrion@qq.com'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(hash.get(<span class="string">'john'</span>))</span><br><span class="line"><span class="comment">// 这里数组储存了三个元素，但是占用了25个空间，感觉很不合理。</span></span><br></pre></td></tr></table></figure><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>目前为止学习的都是一些<code>顺序</code>数据结构，第一个非顺序数据结构是散列表，接下来学习另一种非顺序数据结构-树，对于储存需要快速查找的数据非常有用。</p><p>树是一种分层数据的抽象模型，现实生活中最常见的树的例子就是家谱，系统目录等。</p><h2 id="树的相关术语"><a href="#树的相关术语" class="headerlink" title="树的相关术语"></a>树的相关术语</h2><p>一个树结构包含一系列存在父子的节点，每个节点都有一个父节点，除了顶部的第一个节点以及零个或者多个子节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">               <span class="number">11</span></span><br><span class="line">            /     \</span><br><span class="line">          /         \</span><br><span class="line">        /             \</span><br><span class="line">      <span class="number">7</span>                <span class="number">15</span></span><br><span class="line">   /     \         /      \</span><br><span class="line">  <span class="number">5</span>       <span class="number">9</span>       <span class="number">13</span>      <span class="number">20</span></span><br><span class="line"> / \     / \     /  \    /  \</span><br><span class="line"><span class="number">3</span>   <span class="number">6</span>   <span class="number">8</span>   <span class="number">10</span>  <span class="number">12</span>  <span class="number">14</span>  <span class="number">18</span>  <span class="number">25</span></span><br></pre></td></tr></table></figure><p>位于顶部的 11 叫做根节点，树中的每个元素都叫做节点，节点分为内部节点和外部节点，至少右一个子节点的节点称为内部节点 7,5,9,15,13,20 都是内部节点，没有子元素的节点称为外部节点或者叶节点 3,6,5,10,12,14,18,25 都是叶节点。</p><p>一个节点可以右祖先和后端，一个节点（除了根节点）的祖先包括父节点，祖父节点，曾祖父节点等，一个节点的后代包括子节点，孙子节点，曾孙节点等，例如 8 的祖先节点右 7 和 11，后代节点右 3 和 6</p><p>另外一个有关的术语是子树，子树由节点和它的后代构成，例如 13,12,14 构成了一棵子树</p><p>节点的一个属性是深度，节点的深度取决于它的祖先节点数量，比如节点 3 有三个祖先节点，他的深度为 3.</p><p>树的高度取决于所有节点深度的最大值，一棵树也可以被分解成层级，根节点在 0 层他的子节点在 1 层，以此类推上面的树高度为 3.</p><h2 id="二叉树和二叉搜索树"><a href="#二叉树和二叉搜索树" class="headerlink" title="二叉树和二叉搜索树"></a>二叉树和二叉搜索树</h2><p>二叉树的每个节点只能有两个节点：一个左侧节点，另一个右侧节点，这些定义有助于写出更高效的对树的操作，二叉树在计算机科学中应用很广。（二叉树不能右重复节点，比如系统目录同目录下不能有重名文件夹）</p><p>二叉搜索树 BST 是二叉树的一种，但是他只允许你在左侧节点储存比父节点小的值，右侧节点储存比父节点大的值。</p><p>实现一个二叉树</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(key) &#123;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// insert 向树中插入一个节点</span></span><br><span class="line">  insert (key) &#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.root === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果树为空</span></span><br><span class="line">      <span class="keyword">this</span>.root = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.inserNode(<span class="keyword">this</span>.root, newNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查询插入函数</span></span><br><span class="line"></span><br><span class="line">  inserNode (node, newNode) &#123;</span><br><span class="line">    <span class="comment">// 先判断比当前节点大（右）还是小（左）分别去左或者去右</span></span><br><span class="line">    <span class="keyword">if</span> (newNode.key &lt; node.key) &#123;</span><br><span class="line">      <span class="comment">// 如果left为空直接赋值</span></span><br><span class="line">      <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.left = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不为空递归调用</span></span><br><span class="line">        <span class="keyword">this</span>.inserNode(node.left,newNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 思路和上面一样</span></span><br><span class="line">      <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.right = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.inserNode(node.right, newNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> tree = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line">tree.insert(<span class="number">7</span>)</span><br><span class="line">tree.insert(<span class="number">15</span>)</span><br><span class="line">tree.insert(<span class="number">5</span>)</span><br><span class="line">tree.insert(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(tree)</span><br></pre></td></tr></table></figure><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>遍历一棵树是指访问树的每个节点，并对他们进行某种操作的过程，常用有三种树的遍历方法</p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是从最小到最大的顺序访问所有节点，中序遍历一种应有就是对树进行排序操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InOrderTraverse</span> <span class="keyword">extends</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    inOrderTraverse (node, callback) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node)</span><br><span class="line">        <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.inOrderTraverse(node.left,callback)</span><br><span class="line">            callback(node.key)</span><br><span class="line">            <span class="keyword">this</span>.inOrderTraverse(node.right,callback)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="keyword">new</span> InOrderTraverse()</span><br><span class="line"><span class="keyword">const</span> tree = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line">tree.insert(<span class="number">7</span>)</span><br><span class="line">tree.insert(<span class="number">15</span>)</span><br><span class="line">tree.insert(<span class="number">5</span>)</span><br><span class="line">tree.insert(<span class="number">3</span>)</span><br><span class="line">traverse.inOrderTraverse(tree.root, (key) =&gt; <span class="built_in">console</span>.log(key))</span><br></pre></td></tr></table></figure><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>先序遍历是以优先于后代节点的顺序访问每个节点，先序遍历一种应用是打印结构文档</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PreorderTraverseNode</span> <span class="keyword">extends</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    preOrderTraverse (root,callback) &#123;</span><br><span class="line">      <span class="keyword">this</span>.preOrderTraverseNode(root,callback)</span><br><span class="line">    &#125;</span><br><span class="line">    preOrderTraverseNode(node, callback) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">        callback(node.key);</span><br><span class="line">        <span class="keyword">this</span>.preOrderTraverseNode(node.left,callback);</span><br><span class="line">        <span class="keyword">this</span>.preOrderTraverseNode(node.right, callback)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> PreorderTraverseNode()</span><br><span class="line"><span class="keyword">const</span> tree = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line">tree.insert(<span class="number">7</span>)</span><br><span class="line">tree.insert(<span class="number">15</span>)</span><br><span class="line">tree.insert(<span class="number">5</span>)</span><br><span class="line">tree.insert(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(tree)</span><br><span class="line">a.preOrderTraverse(tree.root,(key) =&gt; <span class="built_in">console</span>.log(key))</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>后序遍历是现房问节点的后代，在访问节点本身，后序遍历应用是计算一个目录和他子目录中所有文件占用空间的大小。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostOrderTraverseNode</span> <span class="keyword">extends</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">   postOrderTraverse (root,callback) &#123;</span><br><span class="line">     <span class="keyword">this</span>.postOrderTraverseNode(root,callback)</span><br><span class="line">   &#125;</span><br><span class="line">  postOrderTraverseNode(node, callback) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node)</span><br><span class="line">    <span class="keyword">if</span>(node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.postOrderTraverseNode(node.left,callback);</span><br><span class="line">      <span class="keyword">this</span>.postOrderTraverseNode(node.right,callback)</span><br><span class="line">      callback(node.key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> PostOrderTraverseNode()</span><br><span class="line"><span class="keyword">const</span> tree = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line">tree.insert(<span class="number">7</span>)</span><br><span class="line">tree.insert(<span class="number">15</span>)</span><br><span class="line">tree.insert(<span class="number">5</span>)</span><br><span class="line">tree.insert(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">b.postOrderTraverse(tree.root, (key) =&gt; <span class="built_in">console</span>.log(key))</span><br></pre></td></tr></table></figure><h3 id="搜索树中的值"><a href="#搜索树中的值" class="headerlink" title="搜索树中的值"></a>搜索树中的值</h3><p>在树中搜索经常有三种搜索：</p><ol><li><p>最小值</p></li><li><p>最大值</p></li><li><p>特定值</p></li></ol><h3 id="搜索最小值和最大值"><a href="#搜索最小值和最大值" class="headerlink" title="搜索最小值和最大值"></a>搜索最小值和最大值</h3><p>根据树的规定，那么最小值一定在最左端的末枝，对应的最大的在最右端。</p><p>先实现最小值方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MidNode</span> <span class="keyword">extends</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  mid (root) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.midNode(root)</span><br><span class="line">  &#125;</span><br><span class="line">  midNode (node) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">      <span class="keyword">while</span>(node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> node.key</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> midNode = <span class="keyword">new</span> MidNode()</span><br><span class="line"><span class="keyword">const</span> tree = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line">tree.insert(<span class="number">7</span>)</span><br><span class="line">tree.insert(<span class="number">15</span>)</span><br><span class="line">tree.insert(<span class="number">5</span>)</span><br><span class="line">tree.insert(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(midNode.mid(tree.root)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>同理最大值就是最右了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxNode</span> <span class="keyword">extends</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  max (root) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.maxNode(root)</span><br><span class="line">  &#125;</span><br><span class="line">  maxNode (node) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">      <span class="keyword">while</span>(node &amp;&amp; node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.right</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> node.key</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> midNode = <span class="keyword">new</span> MaxNode()</span><br><span class="line"><span class="keyword">const</span> tree = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line">tree.insert(<span class="number">7</span>)</span><br><span class="line">tree.insert(<span class="number">15</span>)</span><br><span class="line">tree.insert(<span class="number">5</span>)</span><br><span class="line">tree.insert(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(midNode.max(tree.root))<span class="comment">// 15</span></span><br></pre></td></tr></table></figure><h3 id="搜索特定值"><a href="#搜索特定值" class="headerlink" title="搜索特定值"></a>搜索特定值</h3><p>在 BST 树中实现搜索</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Search</span> <span class="keyword">extends</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  search (root, key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.searchNode(root, key)</span><br><span class="line">  &#125;</span><br><span class="line">  searchNode (node, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) &#123; <span class="comment">// 小于向左</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.serachNode(node.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;<span class="comment">// 大于向右</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.searchNode(node.right, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 不大于不小于就是等于</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> search = <span class="keyword">new</span> Search()</span><br><span class="line"><span class="keyword">const</span> tree = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line">tree.insert(<span class="number">7</span>)</span><br><span class="line">tree.insert(<span class="number">15</span>)</span><br><span class="line">tree.insert(<span class="number">5</span>)</span><br><span class="line">tree.insert(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(search.search(tree.root, <span class="number">7</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="移除一个节点"><a href="#移除一个节点" class="headerlink" title="移除一个节点"></a>移除一个节点</h2><p>移除一个节点比较复杂，因为移除有很多情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Remove</span> <span class="keyword">extends</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">   mid (root) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.midNode(root)</span><br><span class="line">  &#125;</span><br><span class="line">  midNode (node) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">      <span class="keyword">while</span>(node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> node.key</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  remove (root,key) &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">this</span>.removeNode(root, key)</span><br><span class="line">  &#125;</span><br><span class="line">  removeNode (node, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果节点为空</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">      <span class="comment">// 递归左节点</span></span><br><span class="line">      node.left = <span class="keyword">this</span>.removeNode(node.left, key)</span><br><span class="line">      <span class="comment">// 返回值</span></span><br><span class="line">      <span class="keyword">return</span> node</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">      <span class="comment">// 递归右节点</span></span><br><span class="line">      node.right = <span class="keyword">this</span>.removeNode(node.right,key)</span><br><span class="line">      <span class="comment">// 返回值</span></span><br><span class="line">      <span class="keyword">return</span> node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不大于不小于那么就是等于</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 第一种情况它是最末尾的一个叶节点，没有子节点了</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;&amp; node.rhght === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除当前节点的引用</span></span><br><span class="line">        node = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 第二种情况不是叶节点但是只有一个子节点</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.right;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 第三种情况它有两个子节点</span></span><br><span class="line">      <span class="comment">// 思路是使用左叶或者右叶替换掉要被移除的节点</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> aux = <span class="keyword">this</span>.mid(node.right)</span><br><span class="line">      node.key = aux.key</span><br><span class="line">      node.right = <span class="keyword">this</span>.removeNode(node.right, aux.kye)</span><br><span class="line">      <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> remove = <span class="keyword">new</span> Remove()</span><br><span class="line"><span class="keyword">const</span> tree = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line">tree.insert(<span class="number">7</span>)</span><br><span class="line">tree.insert(<span class="number">15</span>)</span><br><span class="line">tree.insert(<span class="number">5</span>)</span><br><span class="line">tree.insert(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(tree.root)</span><br><span class="line">remove.remove(tree.root, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">console</span>.log(tree.root)</span><br></pre></td></tr></table></figure><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><blockquote><p>图是另一种非线性结构，而且图是一个庞大的主题，深入探索图的奇妙世界每个部分都可以写一本书</p></blockquote><p>这一章右很多图，我画不出来。</p><h2 id="图的相关术语"><a href="#图的相关术语" class="headerlink" title="图的相关术语"></a>图的相关术语</h2><p><code>图</code>是网格结构的抽象模型，图是右一组由边链接的节点（或定点），学习图是十分重要的，因为任何二元关系都可以用图来表示</p><p>任何的社交网络如 Facebook 、 微博、 知乎都可以用图来表示</p><p>图在数学和技术上的基础</p><p>一个图 G = (V,E) 由以下元素组成</p><p>V: 一组定点</p><p>E: 一组边，链接 V 中的点</p><p>在着手实现算法之前，先了解一些术语</p><p>由一条边链接在一起的顶点称为相邻顶点</p><p>一个顶点的度是其相邻顶点的数量</p><p>路径是顶点 v1，v2，v3…vk 的一个连续序列，其中 vi 好 vi+1 是相邻的</p><p>简单路径要求不包含重复的顶点，环也是一个简单路径。</p><p>如果图中不存在环，则称该图是无环的，如果图中每两个顶点中都存在路径，那么该图是连通的。</p><h2 id="有向图和无向图"><a href="#有向图和无向图" class="headerlink" title="有向图和无向图"></a>有向图和无向图</h2><p>图可以是无向的（边没有方向）或是有向的（边是右方向的），有向图的边是有一个方向。</p><p>如果图中每两个顶点间在双向都存在路径，则该图是强连通的。</p><p>图还可以是未加权的或者是加权的</p><p>可以使用图来解决计算机科学世界中的很多问题，比如所搜图中的一个特定顶点或搜索特定边，寻找图中一条路径（从一个顶点到另一个顶点），寻找两个顶点之间的最短路径，以及环检测。</p><h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><p>从数据结构的角度来说，右很多种方式来表示图，在所有的表示法中，不存在绝对正确的方式，图的正确表示法取决于待解决的问题和图的类型</p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>图最常见的实现是相邻矩阵，每个节点都和一个整数相关联，该整数将作为数组的索引，我们用一个二维数组来表示顶点之间的链接，如果索引为 i 的节点和索引为 j 的节点相邻，则 array[i][j] === 1， 否则 array[i][j]===0.</p><p>不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会用很多 0，这意味着浪费了计算机储存空间来表示根本不存在的边，例如找给定顶点的相邻顶点，及时该顶点只有一个相邻顶点，也不得不迭代一整行，相邻矩阵表示法不好的另一个理由是图中数量可能会边，二维数组不太灵活。</p><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>另一种表示图的数据结构叫做邻接表，邻接表由途中每个顶点的相邻列表组成，存在好几种方式来实现这种结构，可以使用列表，链表，甚至是散列表或者字典来表示相邻顶点列表。</p><p>尽管邻接表可能对大多数问题来说都是更好的选择，但以上两种表示方法都很有用，且他们有着不同的性质，所以在本书中将使用邻接表表示法。</p><h2 id="创建图类"><a href="#创建图类" class="headerlink" title="创建图类"></a>创建图类</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.vertices = []</span><br><span class="line">        <span class="keyword">this</span>.adjList = <span class="keyword">new</span> <span class="built_in">Map</span>() <span class="comment">// 使用Map数据结构来储存。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个数组来储存所有顶点的名字，以及一个字典来储存邻接表，字典将会使用顶点的名字作为键，邻接顶点列表作为值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.vertices = []</span><br><span class="line">        <span class="keyword">this</span>.adjList = <span class="keyword">new</span> <span class="built_in">Map</span>() <span class="comment">// 使用Map数据结构来储存。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向图中新增一个新的顶点。</span></span><br><span class="line">    addVertex (v) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vertices.push(v);</span><br><span class="line">    <span class="keyword">this</span>.adjList.set(v,[]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    addEdge (v, w) &#123;</span><br><span class="line">    <span class="comment">// 给顶点v添加一条到w的边</span></span><br><span class="line">    <span class="keyword">this</span>.adjList.get(v).push(w)</span><br><span class="line">    <span class="comment">// 相反给顶点w添加一天到v的边</span></span><br><span class="line">    <span class="keyword">this</span>.adjList.get(w).push(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> graph = <span class="keyword">new</span> Graph()</span><br><span class="line"><span class="keyword">const</span> myVerties = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>, <span class="string">'H'</span>, <span class="string">'I'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; myVerties.length; i++) &#123;</span><br><span class="line">graph.addVertex(myVerties[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(graph) <span class="comment">// 如果不好理解的话跑一下这段代码看看这两个console</span></span><br><span class="line">graph.addEdge(<span class="string">'A'</span>,<span class="string">'B'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(graph)</span><br></pre></td></tr></table></figure><h2 id="表的遍历"><a href="#表的遍历" class="headerlink" title="表的遍历"></a>表的遍历</h2><p>和树的数据结构类似，也可以访问图的所有节点，有两种算法可以对图进行遍历，<code>广度优先搜索</code>和<code>深度优先搜索</code>，图遍历可以用来寻找特定的顶点或者寻找两个顶点之间的路径，检查图是否连通是否有环等。</p><p>先理解一下图遍历的思想方法。</p><p>图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有那些节点还没有完全探索，对于良好总图遍历算法，都需要明确指出第一个被访问的顶点。</p><p>完全探索一个顶点要求我们查看该顶点的每一条边，对于每一条边所链接的没有被访问过的顶点，将其标注为发现，并将其加进待访问顶点列表中。</p><p>为了保证算法的效率，务必访问每个顶点两次，连通图中每条边和顶点都会被访问到。</p><p>广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是待访问顶点列表的数据结构</p><p>深度优先使用栈，通过将顶点存入占中，顶点是沿着路径被弹错的，存在的新的 邻顶点就过去访问。</p><p>广度优先使用队列，通过将顶点存入队列中，先进入队列的顶点先被探索。</p><p>当要标注已经被访问过的顶点时候使用三种颜色来翻译他们的状态</p><p>白色，表示该顶点还没有被访问过</p><p>灰色，表示该顶点被访问过，但是并未被探索</p><p>黑色，表示该顶点被访问过且被完全探索过</p><p>这就是之前提到的务必访问每个顶点最多两次的原因。</p><h2 id="广度优先算法"><a href="#广度优先算法" class="headerlink" title="广度优先算法"></a>广度优先算法</h2><p>广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻节点，就像一次访问图的一层，换句话说就是先宽后深的访问顶点。</p><p>以下是从顶点 v 开始广度搜索算法所遵循的步骤</p><ol><li><p>先创建一个列队 Q</p></li><li><p>将 v 标注为被发现灰色，并将 v 加入队列 Q</p></li><li><p>如果 Q 非空，则运行以下步骤：</p><ol><li>将 u 从 Q 中出队列</li><li>将标注为 U 为被发现的灰色</li><li>将 U 所有未被访问过的邻节点白色加入列队Ｑ</li><li>将Ｕ标注为已被探索的黑色</li></ol></li></ol><p>文字看不太懂，先看看代码如何实现的吧</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="comment">// 声明一个数组保存队列里的元素</span></span><br><span class="line">        <span class="keyword">this</span>.items = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加元素到队列末尾</span></span><br><span class="line">    enqueue (element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 移除并返回队列第一个元素</span></span><br><span class="line">    dequeue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.shift()</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 返回队列第一个元素</span></span><br><span class="line">    front() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//  判断元素是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//  清空队列</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = []</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//  返回队列元素长度</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> items.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印队列</span></span><br><span class="line">    print() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.items)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.vertices = []</span><br><span class="line">        <span class="keyword">this</span>.adjList = <span class="keyword">new</span> <span class="built_in">Map</span>() <span class="comment">// 使用Map数据结构来储存。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向图中新增一个新的顶点。</span></span><br><span class="line">    addVertex (v) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vertices.push(v);</span><br><span class="line">    <span class="keyword">this</span>.adjList.set(v,[]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    addEdge (v, w) &#123;</span><br><span class="line">    <span class="comment">// 给顶点v添加一条到w的边</span></span><br><span class="line">    <span class="keyword">this</span>.adjList.get(v).push(w)</span><br><span class="line">    <span class="comment">// 相反给顶点w添加一天到v的边</span></span><br><span class="line">    <span class="keyword">this</span>.adjList.get(w).push(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initializeColor () &#123;</span><br><span class="line">      <span class="keyword">const</span> color = []</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.vertices.length; i++) &#123;</span><br><span class="line">        color[<span class="keyword">this</span>.vertices[i]] = <span class="string">'white'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bfs (v, callback) &#123;</span><br><span class="line">        <span class="keyword">let</span> color = <span class="keyword">this</span>.initializeColor(); <span class="comment">// 将所有顶点渲染为白色</span></span><br><span class="line">      <span class="keyword">const</span> queue = <span class="keyword">new</span> Queue(); <span class="comment">// 生成队列</span></span><br><span class="line">      queue.enqueue(v); <span class="comment">// 添加入队</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (!queue.isEmpty()) &#123; <span class="comment">// 如果列队不为空</span></span><br><span class="line">        <span class="keyword">let</span> u = queue.dequeue(); <span class="comment">// 从列队中出队第一个顶点</span></span><br><span class="line">        <span class="keyword">let</span> neighbors = <span class="keyword">this</span>.adjList.get(u);<span class="comment">//取得这个顶点包含其所有林甸的邻接表</span></span><br><span class="line"></span><br><span class="line">       color[u] = <span class="string">'grey'</span>; <span class="comment">// 标记顶点被访问过，但是没有被探索过</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 访问这个顶点的边</span></span><br><span class="line">          <span class="keyword">const</span> w = neighbors[i];</span><br><span class="line">          <span class="keyword">if</span> (color[w] === <span class="string">'white'</span>) &#123; <span class="comment">// 如果它还没有被访问过则将他标记为已访问</span></span><br><span class="line">            color[w] = <span class="string">'grey'</span>;</span><br><span class="line">            queue.enqueue(w); <span class="comment">// 并将这个顶点加入队列中</span></span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       color[u] = <span class="string">'black'</span>; <span class="comment">// 当完成探索该顶点和相邻顶点后将其标注为已探索的黑色</span></span><br><span class="line">       <span class="keyword">if</span> (callback) &#123;<span class="comment">// 判断有没有回调如果右执行回调</span></span><br><span class="line">       callback(u)</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> graph = <span class="keyword">new</span> Graph()</span><br><span class="line"><span class="keyword">const</span> myVerties = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>, <span class="string">'H'</span>, <span class="string">'I'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; myVerties.length; i++) &#123;</span><br><span class="line">graph.addVertex(myVerties[i])</span><br><span class="line">&#125;</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>,<span class="string">'B'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>,<span class="string">'C'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>,<span class="string">'D'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'C'</span>,<span class="string">'D'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'C'</span>,<span class="string">'G'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'D'</span>,<span class="string">'G'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'D'</span>,<span class="string">'H'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>,<span class="string">'E'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>,<span class="string">'F'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'E'</span>,<span class="string">'I'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printNode</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'访问了顶点'</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">graph.bfs(myVerties[<span class="number">0</span>],printNode)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一知半解的感觉，代码实现上没有错误，感觉反正让我写我写不出来</span></span><br></pre></td></tr></table></figure><h3 id="使用-BFS-寻找最短路径"><a href="#使用-BFS-寻找最短路径" class="headerlink" title="使用 BFS 寻找最短路径"></a>使用 BFS 寻找最短路径</h3><p>使用 BFS 搜索来解决一个问题</p><p>给定一个图的 G 和源顶点 V，找出对每个顶点 U，U 和 V 之间的最短路径的距离，以边的数量多少来衡量。</p><p>对于给定顶点 V，广度优先搜索 hUI 访问所有与其距离为 1 的顶点，接着是距离为 2 的顶点，以此类推，所以可以使用广度优先算法来解决这个问题，修改 bfs 方法返回给我们一些信息：<br>从 V 到 U 的距离 d[U]<br>前溯点 pred[U]，用来推到出从 V 到其他每个顶点 U 的最短路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="comment">// 声明一个数组保存队列里的元素</span></span><br><span class="line">        <span class="keyword">this</span>.items = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加元素到队列末尾</span></span><br><span class="line">    enqueue (element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 移除并返回队列第一个元素</span></span><br><span class="line">    dequeue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.shift()</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 返回队列第一个元素</span></span><br><span class="line">    front() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//  判断元素是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//  清空队列</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = []</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//  返回队列元素长度</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> items.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印队列</span></span><br><span class="line">    print() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.items)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.vertices = []</span><br><span class="line">        <span class="keyword">this</span>.adjList = <span class="keyword">new</span> <span class="built_in">Map</span>() <span class="comment">// 使用Map数据结构来储存。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向图中新增一个新的顶点。</span></span><br><span class="line">    addVertex (v) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vertices.push(v);</span><br><span class="line">    <span class="keyword">this</span>.adjList.set(v,[]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    addEdge (v, w) &#123;</span><br><span class="line">    <span class="comment">// 给顶点v添加一条到w的边</span></span><br><span class="line">    <span class="keyword">this</span>.adjList.get(v).push(w)</span><br><span class="line">    <span class="comment">// 相反给顶点w添加一天到v的边</span></span><br><span class="line">    <span class="keyword">this</span>.adjList.get(w).push(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initializeColor () &#123;</span><br><span class="line">      <span class="keyword">const</span> color = []</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.vertices.length; i++) &#123;</span><br><span class="line">        color[<span class="keyword">this</span>.vertices[i]] = <span class="string">'white'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bfs (v, callback) &#123;</span><br><span class="line">      <span class="keyword">let</span> color = <span class="keyword">this</span>.initializeColor()</span><br><span class="line">      <span class="keyword">const</span> queue = <span class="keyword">new</span> Queue()</span><br><span class="line">      <span class="keyword">let</span> d = [], pred = [];</span><br><span class="line">      queue.enqueue(v);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.vertices.length; i ++) &#123;</span><br><span class="line">      d[<span class="keyword">this</span>.vertices[i]] = <span class="number">0</span>;</span><br><span class="line">      pred[<span class="keyword">this</span>.vertices[i]] = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">const</span> u =  queue.dequeue();</span><br><span class="line">      <span class="keyword">let</span> neighbors = <span class="keyword">this</span>.adjList.get(u)</span><br><span class="line">      color[u] = <span class="string">'grey'</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i =<span class="number">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> w = neighbors[i]</span><br><span class="line">        <span class="keyword">if</span> (color[w] === <span class="string">'white'</span>) &#123;</span><br><span class="line">          color[w] = <span class="string">'grey'</span></span><br><span class="line">          d[w] = d[u] + <span class="number">1</span>;</span><br><span class="line">          pred[w] = u</span><br><span class="line">          queue.enqueue(w)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      color[u] = <span class="string">'black'</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">      distances: d,</span><br><span class="line">      predecessors: pred</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> graph = <span class="keyword">new</span> Graph()</span><br><span class="line"><span class="keyword">const</span> myVerties = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>, <span class="string">'H'</span>, <span class="string">'I'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; myVerties.length; i++) &#123;</span><br><span class="line">graph.addVertex(myVerties[i])</span><br><span class="line">&#125;</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>,<span class="string">'B'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>,<span class="string">'C'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>,<span class="string">'D'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'C'</span>,<span class="string">'D'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'C'</span>,<span class="string">'G'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'D'</span>,<span class="string">'G'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'D'</span>,<span class="string">'H'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>,<span class="string">'E'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>,<span class="string">'F'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'E'</span>,<span class="string">'I'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(graph.bfs(myVerties[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><p>深入学习最短路径算法</p><p>上面的图是不加权的，如果要在加权图中寻找最短路径，例如城市 A 到城市 B 之间的最短路径，那么广度优先搜索未必合适。</p><p>有很多专用其他的算法，来对应不同情况下最短路径问题，正如前面所说的，图是一个广泛的主题，单单一个最短路径问题和他的变种问题就右很多很多解决方案，但是在学习这些方案之前，需要很好的掌握图的基本概念，从而更轻松的学习其他解决方案。</p><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径一直到这条路径最后一个顶点被访问，接着按原路回退探索下一条路径，换句话说，他是先深度后广度的访问顶点。</p><p>深度优先搜索算法不需要一个源顶点，在深度优先算法中，若图中顶点 V 未被访问，则访问该顶点 V，要访问顶点 V，需要按照一下步骤进行。</p><ol><li><p>标注 V 为未发现的灰色</p></li><li><p>对于 V 的所有未访问的邻点 W 都进行一次访问</p></li><li><p>将 V 标记为已探索</p></li></ol><p>深度优先搜索的步骤是递归，这意味着深度优先搜索算法使用栈来储存函数调用，由递归函数调用所创建的栈。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.vertices = []</span><br><span class="line">         <span class="keyword">this</span>.adjList = <span class="keyword">new</span> <span class="built_in">Map</span>() <span class="comment">// 使用Map数据结构来储存。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向图中新增一个新的顶点。</span></span><br><span class="line">    addVertex (v) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vertices.push(v);</span><br><span class="line">    <span class="keyword">this</span>.adjList.set(v,[]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    addEdge (v, w) &#123;</span><br><span class="line">    <span class="comment">// 给顶点v添加一条到w的边</span></span><br><span class="line">    <span class="keyword">this</span>.adjList.get(v).push(w)</span><br><span class="line">    <span class="comment">// 相反给顶点w添加一天到v的边</span></span><br><span class="line">    <span class="keyword">this</span>.adjList.get(w).push(v)</span><br><span class="line">    &#125;</span><br><span class="line">    dfsVisit (u, color, callback) &#123;</span><br><span class="line">      color[u] = <span class="string">'grey'</span>;</span><br><span class="line">      <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">      callback(u)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> neighbors = <span class="keyword">this</span>.adjList.get(u)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> w = neighbors[i]</span><br><span class="line">      <span class="keyword">if</span> (color[w] === <span class="string">'white'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dfsVisit(w,color,callback);</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      color[u] = <span class="string">'black'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    initializeColor () &#123;</span><br><span class="line">        <span class="keyword">const</span> color = []</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.vertices.length; i++) &#123;</span><br><span class="line">        color[<span class="keyword">this</span>.vertices[i]] = <span class="string">'white'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs (callback) &#123;</span><br><span class="line">        <span class="keyword">let</span> color = <span class="keyword">this</span>.initializeColor();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.vertices.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (color[<span class="keyword">this</span>.vertices[i]] === <span class="string">'white'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.dfsVisit(<span class="keyword">this</span>.vertices[i],color,callback)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> graph = <span class="keyword">new</span> Graph()</span><br><span class="line"><span class="keyword">const</span> myVerties = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>, <span class="string">'H'</span>, <span class="string">'I'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; myVerties.length; i++) &#123;</span><br><span class="line">graph.addVertex(myVerties[i])</span><br><span class="line">&#125;</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>,<span class="string">'B'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>,<span class="string">'C'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>,<span class="string">'D'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'C'</span>,<span class="string">'D'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'C'</span>,<span class="string">'G'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'D'</span>,<span class="string">'G'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'D'</span>,<span class="string">'H'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>,<span class="string">'E'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>,<span class="string">'F'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'E'</span>,<span class="string">'I'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printNode</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'访问了顶点'</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(graph)</span><br><span class="line"><span class="built_in">console</span>.log(graph.dfs(printNode))</span><br></pre></td></tr></table></figure><h1 id="排序和搜索算法"><a href="#排序和搜索算法" class="headerlink" title="排序和搜索算法"></a>排序和搜索算法</h1><p>在日常生活中需要值信息，比如春村在数据结构里面的信息，排序和搜索算法广泛的运用在解决日常生活问题中。</p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>从最简单的开始</p><p>先实现一个用来表示待排序和搜索的数据结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.array = []</span><br><span class="line">    &#125;</span><br><span class="line">    insert (item) &#123;</span><br><span class="line">        array.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    toString () &#123;</span><br><span class="line">        <span class="keyword">return</span> array.join()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面实现了一个非常简单的数据结构他将项储存在数组中，并且写了一个方法向数据结构中添加元素，为了帮助验证结果结果重写了 toSting 方法。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是所有排序算法中最简单的，然而从时间复杂度来看他是最差的。</p><p>冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换他们，元素向上移动到正确的位置，好像气泡升至表面一样，冒泡排序因此得名。</p><p>实现以下冒泡排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.array = []</span><br><span class="line">    &#125;</span><br><span class="line">    insert (item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.array.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    toString () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.array.join()</span><br><span class="line">    &#125;</span><br><span class="line">    swap(index1, index2) &#123;</span><br><span class="line">    <span class="comment">// 交换数组的两个元素</span></span><br><span class="line">      <span class="keyword">const</span> aux = <span class="keyword">this</span>.array[index1]</span><br><span class="line">      <span class="keyword">this</span>.array[index1] = <span class="keyword">this</span>.array[index2]</span><br><span class="line">      <span class="keyword">this</span>.array[index2] = aux</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 冒泡排序</span></span><br><span class="line">    bubbleSort () &#123;</span><br><span class="line">      <span class="keyword">const</span> length = <span class="keyword">this</span>.array.length</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.array[j] &gt; <span class="keyword">this</span>.array[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.swap(j, j+<span class="number">1</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试排序代码</span></span><br><span class="line"><span class="comment">// 逆序创建一个ArrayList</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNonSortedArray</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="keyword">new</span> ArrayList()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = size; i &gt; <span class="number">0</span>; i --) &#123;</span><br><span class="line">    arr.insert(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = createNonSortedArray(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">// 确定为逆序</span></span><br><span class="line">arr.bubbleSort()</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">// 确定排序完毕</span></span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.array = []</span><br><span class="line">    &#125;</span><br><span class="line">    insert (item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.array.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    toString () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.array.join()</span><br><span class="line">    &#125;</span><br><span class="line">    swap(index1, index2) &#123;</span><br><span class="line">    <span class="comment">// 交换数组的两个元素</span></span><br><span class="line">      <span class="keyword">const</span> aux = <span class="keyword">this</span>.array[index1]</span><br><span class="line">      <span class="keyword">this</span>.array[index1] = <span class="keyword">this</span>.array[index2]</span><br><span class="line">      <span class="keyword">this</span>.array[index2] = aux</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   selectionSort () &#123;</span><br><span class="line">        <span class="keyword">const</span> length = <span class="keyword">this</span>.array.length</span><br><span class="line">        <span class="keyword">let</span> indexMin</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        indexMin = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.array[indexMin]&gt;<span class="keyword">this</span>.array[j])</span><br><span class="line">            indexMin = j</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i !== indexMin) &#123;</span><br><span class="line">            <span class="keyword">this</span>.swap(i,indexMin)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试排序代码</span></span><br><span class="line"><span class="comment">// 逆序创建一个ArrayList</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNonSortedArray</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="keyword">new</span> ArrayList()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = size; i &gt; <span class="number">0</span>; i --) &#123;</span><br><span class="line">    arr.insert(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = createNonSortedArray(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">// 确定为逆序</span></span><br><span class="line">arr.selectionSort()</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">// 确定排序完毕</span></span><br></pre></td></tr></table></figure><p>这两段排序的时间复杂度都是 O(n²)，他们都有两个嵌套循环，这导致了二次方的复杂度。</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序每次排一个数组项，以此方式构建最后的排序数组，假设第一项已经排序了，接着他和第二项进行比较，第二项是应该待在原位还是插到第一项之前，这样头两项就已正确排序，接着比较第三项。判断他应该在哪里。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.array = []</span><br><span class="line">    &#125;</span><br><span class="line">    insert (item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.array.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    toString () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.array.join()</span><br><span class="line">    &#125;</span><br><span class="line">    swap(index1, index2) &#123;</span><br><span class="line">    <span class="comment">// 交换数组的两个元素</span></span><br><span class="line">        <span class="keyword">const</span> aux = <span class="keyword">this</span>.array[index1]</span><br><span class="line">      <span class="keyword">this</span>.array[index1] = <span class="keyword">this</span>.array[index2]</span><br><span class="line">      <span class="keyword">this</span>.array[index2] = aux</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   insertionSort () &#123;</span><br><span class="line">   <span class="keyword">const</span> length = <span class="keyword">this</span>.array.length</span><br><span class="line">   <span class="keyword">let</span> j, temp</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    j = i</span><br><span class="line">    temp = <span class="keyword">this</span>.array[i]</span><br><span class="line">    <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.array[j<span class="number">-1</span>] &gt; temp) &#123;</span><br><span class="line">        <span class="keyword">this</span>.array[j] = <span class="keyword">this</span>.array[j<span class="number">-1</span>]</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.array[j] = temp</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试排序代码</span></span><br><span class="line"><span class="comment">// 逆序创建一个ArrayList</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNonSortedArray</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="keyword">new</span> ArrayList()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = size; i &gt; <span class="number">0</span>; i --) &#123;</span><br><span class="line">    arr.insert(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = createNonSortedArray(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">// 确定为逆序</span></span><br><span class="line">arr.insertionSort()</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">// 确定排序完毕</span></span><br></pre></td></tr></table></figure><p>在排序小型数组时候，其效率高于冒泡排序</p><h3 id="并归排序"><a href="#并归排序" class="headerlink" title="并归排序"></a>并归排序</h3><p>并归排序是一个可以被实际使用的排序算法，并归排序的算法复杂度为 O(n log n 次方)</p><p>JavaScript 的 Array 定义了一个 sort 函数，用于培训 JavaScript 数组，但是 ECMASsript 并没有规定使用那种算法进行排序，个浏览器厂商可以自行实现算法，那么火狐使用了并归排序，谷歌则使用了排序排序。</p><p>并归排序是一种分治算法，其思想是将原始数组分割成较小的数组，直到每个小数组只有一个位置，接着将小数组合并成大数组，最后只有一个排序完毕的大数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.array = []</span><br><span class="line">    &#125;</span><br><span class="line">    insert (item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.array.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    toString () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.array.join()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 并归函数入口</span></span><br><span class="line">   mergeSort () &#123;</span><br><span class="line">    <span class="keyword">this</span>.array = <span class="keyword">this</span>.mergeSortRec(<span class="keyword">this</span>.array)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将数组递归拆分成只有一个元素的数组</span></span><br><span class="line">   mergeSortRec (array) &#123;</span><br><span class="line">    <span class="keyword">const</span> length = array.length</span><br><span class="line">      <span class="keyword">if</span> (length === <span class="number">1</span>) &#123;<span class="comment">// 递归函数终止条件</span></span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>);  <span class="comment">// 取得中间值</span></span><br><span class="line">      <span class="keyword">const</span> left = array.slice(<span class="number">0</span>,mid), <span class="comment">// 左切片</span></span><br><span class="line">            right = array.slice(mid, length); <span class="comment">// 右切片</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.merge(<span class="keyword">this</span>.mergeSortRec(left), <span class="keyword">this</span>.mergeSortRec(right)) <span class="comment">// 递归调用。</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   merge(left, right) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(left, right) <span class="comment">// 如果理解不了的话可以看控制台打印出来的内容然后带入下面的迭代就比较好懂了。</span></span><br><span class="line">    <span class="keyword">const</span> result = [] <span class="comment">// 声明一个数组用来储存归并过程中的新数组</span></span><br><span class="line">    <span class="keyword">let</span> il = <span class="number">0</span>, ir = <span class="number">0</span>;<span class="comment">// 两个用于迭代的变量</span></span><br><span class="line">    <span class="keyword">while</span>(il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; <span class="comment">// 迭代两个数组</span></span><br><span class="line">        <span class="keyword">if</span> (left[il] &lt; right[ir]) &#123; <span class="comment">// 对比左边是否小于右边</span></span><br><span class="line">        result.push(left[il++]); <span class="comment">// 如果是那么将左边添加到数组</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.push(right[ir++]); <span class="comment">// 如果不是则将右边添加到数组</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (il &lt; left.length) &#123; <span class="comment">// 接下来将左边数组剩余项添加到归并数组中</span></span><br><span class="line">        result.push(left[il++])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ir &lt; right.length) &#123; <span class="comment">// 将右边数组生育项添加到归并数组中</span></span><br><span class="line">        result.push(right[ir++])</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> result</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试排序代码</span></span><br><span class="line"><span class="comment">// 逆序创建一个ArrayList</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> ArrayList()</span><br><span class="line">arr.insert(<span class="number">4</span>)</span><br><span class="line">arr.insert(<span class="number">2</span>)</span><br><span class="line">arr.insert(<span class="number">8</span>)</span><br><span class="line">arr.insert(<span class="number">3</span>)</span><br><span class="line">arr.insert(<span class="number">5</span>)</span><br><span class="line">arr.insert(<span class="number">1</span>)</span><br><span class="line">arr.insert(<span class="number">7</span>)</span><br><span class="line">arr.insert(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">// 确定为逆序</span></span><br><span class="line">arr.mergeSort()</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">// 确定排序完毕</span></span><br></pre></td></tr></table></figure><p>这段代码理解起来比较复杂，首先对递归有了新的认识，从运算结果推断过程，还有就是发明这个算法的人真的好聪明。</p><p>学习这段代码的时候我是一部一部 console 打印过来的。我在代码中留下了其中最重要的一个 console，根据 console 的内容来带入运行，就可以比较轻松地理解排序过程了。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序也许是最常用的排序算法了，他的复杂度为 O(n log 的 n 次方)，而且他的性能通常比其他复杂度相同的排序算法要好，和归并排序一样，快速排序也使用分治的方法，将原始数组分为较小的数组，但是他没有想归并排序那样将数组分割开。</p><p>快速排序相对比较复杂逻辑实现分为一下步骤：</p><ol><li><p>从数组中间项作为主元</p></li><li><p>创建两个指针，左边指向数组的第一项，右边指向数组最后一项，移动左指针直到找到比主元大的元素，接着移动右指针直到找到一个比主元小的元素，然后交换他们，重复这个过程，直到左指针超过了右指针，这个过程中将使比主元小的小的值都排在主元之前，而比主元大的值都排在主元之后，这一步叫做划分操作</p></li><li><p>接着，算法对划分之后的小数组，小数组是指比主元小的值组成的子数组，以及较主元大的值组成的子数组，重复之前的两个步骤，直到数组完成排序。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.array = []</span><br><span class="line">    &#125;</span><br><span class="line">    insert (item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.array.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    toString () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.array.join()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速排序入口</span></span><br><span class="line"></span><br><span class="line">  quickSort () &#123;</span><br><span class="line">    <span class="comment">// 调用递归函数传入数组，和数组开始及结束位置下标</span></span><br><span class="line">    <span class="keyword">this</span>.quick(<span class="keyword">this</span>.array, <span class="number">0</span>, <span class="keyword">this</span>.array.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  quick (array, left, right) &#123;</span><br><span class="line">    <span class="keyword">let</span> index; <span class="comment">// 声明一个变量用于储存分离较小数组和较大数组（在它左边的就是小他右边的就是大）</span></span><br><span class="line">    <span class="keyword">if</span> (array.length &gt; <span class="number">1</span>) &#123; <span class="comment">// 数组元素小于1就不进行排序</span></span><br><span class="line">        index = <span class="keyword">this</span>.partition(array, left, right)</span><br><span class="line">      <span class="keyword">if</span> (left &lt; index <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.quick(array, left, index <span class="number">-1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (index &lt; right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.quick(array,index,right)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  partition(array, left, right) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(array,left, right)</span><br><span class="line">    <span class="keyword">const</span> pivot = array[<span class="built_in">Math</span>.floor((right + left)/<span class="number">2</span>)]</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'中间值下标'</span>,pivot)</span><br><span class="line">    <span class="keyword">let</span> i = left, j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'while迭代'</span>,array, i, j)</span><br><span class="line">        <span class="keyword">while</span>(array[i] &lt; pivot) &#123;</span><br><span class="line">        i++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(array[j] &gt; pivot) &#123;</span><br><span class="line">        j--</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">this</span>.swapQuickSort(array, i, j)</span><br><span class="line">        i++</span><br><span class="line">        j--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'返回i'</span>,i)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">  &#125;</span><br><span class="line">  swapQuickSort(array, index1, index2) &#123;</span><br><span class="line">    <span class="keyword">const</span> aux = <span class="keyword">this</span>.array[index1]</span><br><span class="line">    <span class="keyword">this</span>.array[index1] = <span class="keyword">this</span>.array[index2]</span><br><span class="line">    <span class="keyword">this</span>.array[index2] = aux</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试排序代码</span></span><br><span class="line"><span class="comment">// 逆序创建一个ArrayList</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> ArrayList()</span><br><span class="line">arr.insert(<span class="number">4</span>)</span><br><span class="line">arr.insert(<span class="number">2</span>)</span><br><span class="line">arr.insert(<span class="number">8</span>)</span><br><span class="line">arr.insert(<span class="number">3</span>)</span><br><span class="line">arr.insert(<span class="number">5</span>)</span><br><span class="line">arr.insert(<span class="number">1</span>)</span><br><span class="line">arr.insert(<span class="number">7</span>)</span><br><span class="line">arr.insert(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">// 确定为逆序</span></span><br><span class="line">arr.quickSort()</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">// 确定排序完毕</span></span><br></pre></td></tr></table></figure><p>快速排序较为复杂，需要多多进行理解，同样的我在代码中留下了比较方便理解代码运行的 console，拿着这个值去带入代码，在脑中或者在书上模拟代码运行就比较好理解了。</p><h1 id="算法知识补充"><a href="#算法知识补充" class="headerlink" title="算法知识补充"></a>算法知识补充</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归是一种解决问题的方法，他解决问题的各个小部分，直到解决最初的大问题，通常设计函数调用自身</p><p>能够像下面这样直接调用自身的方法或者函数，是递归函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> recursiveFunction = <span class="function"><span class="keyword">function</span>(<span class="params">someParam</span>) </span>&#123;</span><br><span class="line">    recursiveFunction(someParam)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意递归函数一定要设置终止条件，像上面的代码会直接死循环导致内存溢出。</span></span><br></pre></td></tr></table></figure><h3 id="JavaScript-调用栈大小限制"><a href="#JavaScript-调用栈大小限制" class="headerlink" title="JavaScript 调用栈大小限制"></a>JavaScript 调用栈大小限制</h3><p>如果忘记加上停止函数递归调用条件的边界，递归并不会无限制的执行下去，浏览器会抛出异常，也就是栈溢出错误。</p><p>每个浏览器都有自己的上线，可以用一下代码进行测试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    i++</span><br><span class="line">  Fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Fn()</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`i = <span class="subst">$&#123;i&#125;</span>, error = <span class="subst">$&#123;error&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我在Chrome65中得到结果，但是如果在代码中加上一个console的话这个值就会超过15672，我也不知道最终是多少。谷歌可能对死循环有优化。</span></span><br><span class="line"><span class="comment">// i = 15672, error = RangeError: Maximum call stack size exceeded</span></span><br><span class="line"><span class="comment">// 在火狐59中得到结果,而且这个值是不断变化的上下有几万次的浮动</span></span><br><span class="line"><span class="comment">// i = 308087, error = InternalError: too much recursion</span></span><br></pre></td></tr></table></figure><p>在 ECMAScript6 中有尾递归优化，如果函数内最后一个操作是函数调用，就会通过跳转指令，而不是子程序调用来控制，也就是说在 ES6 中这样的代码会一直执行下去，并不会出错。所以具备终止条件的非常重要。</p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>斐波那契数列定义如下：</p><ol><li><p>1 和 2 的斐波那契数是 1</p></li><li><p>n(n&gt;2)的斐波那契数是(n-1)的斐波那契树机上(n-2)的斐波那契数</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">1</span> || num ===<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fibonacci(num - <span class="number">1</span>) + fibonacci(num - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fibonacci(<span class="number">20</span>))</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n1 = <span class="number">1</span>,</span><br><span class="line">      n2 = <span class="number">1</span>,</span><br><span class="line">      n=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt; num; i++) &#123;</span><br><span class="line">    n =  n1 + n2</span><br><span class="line">    n1 = n2</span><br><span class="line">    n2 = n</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fib(<span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码分别是递归和非递归版本，通过打点计时</span></span><br><span class="line"><span class="comment">// 递归函数在1.5ms  1: 1.541015625ms</span></span><br><span class="line"><span class="comment">// 而循环版本则只有0.08ms  2: 0.080078125ms</span></span><br></pre></td></tr></table></figure><p>那为什么还使用递归呢，递归并不比普通版本快，反而更慢，但是递归函数容易理解，也容易第一时间想到，所需要的代码量也更少。</p><p>在 ES6 中因为尾递归优化的缘故，递归并不比迭代慢，但是在其他语言中递归通常更慢。</p><blockquote><p>注意,经查证 ES6 规范是规定了尾递归优化，但是规范落地的时候出现了分歧，具体了解请点击这里<a href="https://75team.com/post/v8-es6-es7-and-beyond.html" target="_blank" rel="noopener">V8 团队眼中的 ES6、ES7 及未来</a></p></blockquote><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规范是一种将复杂问题分解成更小的子问题来解决的优化技术。</p><p>使用动态规划解决问题，要遵循三个重要步骤：</p><ol><li><p>定义子问题</p></li><li><p>要实现反复执行而解决子问题的一部分</p></li><li><p>识别并求出边界条件</p></li></ol><p>能用动态规划解决一些著名的问题如下：</p><p>背包问题：给出一组项目，各自有值和容量，目前是找出总值最大的集合，这个问题的限制是，容量必须小于等于背包的容量</p><p>最长共因子序列：找出一组序列的最长公因子序列，可由另一序列删除元素但不会改变余下元素的序列而得到</p><p>矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效方法</p><p>图的全源最短路径：对所有的顶点对，找出从顶点到另一个顶点的最短路径</p><h3 id="大-O-表示法"><a href="#大-O-表示法" class="headerlink" title="大 O 表示法"></a>大 O 表示法</h3><p>大 O 表示法的概念是描述算法的性能和复杂度<br>在分析算法时候时常遇到以下积累函数：</p><p>O(1) 常数的<br>O(log(n)) 对数的<br>O((log(n))c) 对数多项式的<br>O(n) 线性的<br>O(n²) 二次的<br>O(n 的 c 次方) 多项式的<br>O(n 的次方) 指数的</p><h3 id="理解大-O-表示法"><a href="#理解大-O-表示法" class="headerlink" title="理解大 O 表示法"></a>理解大 O 表示法</h3><p>衡量算法的效率，通常是用资源，例如 CPU 占用时间，内存占用，硬盘占用，当讨论大 O 表示法时，一般指 CPU 占用时间。</p><ol><li>O(1)</li></ol><p>考虑一下函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设 num 为 1 时执行函数时间为 X，那么当 num 为 N 时，执行函数时间还是 X，运行时间是恒定的，和参数没有关系。</p><ol start="2"><li>O(n)</li></ol><p>以下面的函数为例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params">array, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(item === array[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将 10 个元素的数组传给这个函数 Fn，并且搜索 1，那么第一次判断就能找到这个元素，那么开销是 1,</p><p>如果要搜索的值是 11，那么他会判断 10 次发现数组内元素都不等，第十次返回-1，如果有 1000 个元素搜索 1001，执行 1000 次然后返回-1</p><p>所以最好情况下是 1，最坏情况下就是 Array 的长度，所以复杂度是 O(n)，n 为输入数组的大小</p><ol start="3"><li>O(n²)</li></ol><p>使用冒泡排序来做 O(n²)的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span> (<span class="params">array, index1, index2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> aux = array[index1]</span><br><span class="line">    array[index1] = array[index2]</span><br><span class="line">    array[index2] = aux</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fonction bubbleSort (array) &#123;</span><br><span class="line">    <span class="keyword">const</span> length = array.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(array, j, i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入一个长度为 10 的数组，开销是 100，即 10 的平方，如果用长度 100 的数组那么开销是 10000，随着每次传入参数的大小不同，执行时间长短也不同。</p><p>简单的分析复杂度可以看函数内部有嵌套右多少层循环，O(n)只有一层循环，而 O(n²)则嵌套有两层循环，如果右三层嵌套循环那么他的复杂度可能就是 O(n³)</p><p>完结撒花。。。看下一本。。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/数据结构/" rel="tag"># 数据结构</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/03/31/数据结构学习四树/" rel="next" title="数据结构学习四树"><i class="fa fa-chevron-left"></i> 数据结构学习四树</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2018/04/05/程序员的数学-基础数学/" rel="prev" title="程序员的数学-基础数学">程序员的数学-基础数学<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">H</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">51</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">24</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/HiMrHu" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript-基础"><span class="nav-number">1.</span> <span class="nav-text">JavaScript 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#变量"><span class="nav-number">1.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量作用域"><span class="nav-number">1.2.</span> <span class="nav-text">变量作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作符"><span class="nav-number">1.3.</span> <span class="nav-text">操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构控制"><span class="nav-number">1.4.</span> <span class="nav-text">结构控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">1.5.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象"><span class="nav-number">1.6.</span> <span class="nav-text">对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象编程"><span class="nav-number">1.7.</span> <span class="nav-text">面向对象编程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组"><span class="nav-number">2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#添加删除数组元素"><span class="nav-number">2.1.</span> <span class="nav-text">添加删除数组元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二维数组"><span class="nav-number">2.2.</span> <span class="nav-text">二维数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组合并"><span class="nav-number">2.3.</span> <span class="nav-text">数组合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组迭代"><span class="nav-number">2.4.</span> <span class="nav-text">数组迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#搜索和排序"><span class="nav-number">2.5.</span> <span class="nav-text">搜索和排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#栈"><span class="nav-number">3.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#栈的创建"><span class="nav-number">3.1.</span> <span class="nav-text">栈的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#例子十进制到二进制的转换"><span class="nav-number">3.2.</span> <span class="nav-text">例子十进制到二进制的转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#队列"><span class="nav-number">4.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建列队"><span class="nav-number">4.1.</span> <span class="nav-text">创建列队</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用队列"><span class="nav-number">4.2.</span> <span class="nav-text">使用队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列优先"><span class="nav-number">4.3.</span> <span class="nav-text">队列优先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环队列–击鼓传花"><span class="nav-number">4.4.</span> <span class="nav-text">循环队列–击鼓传花</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链表"><span class="nav-number">5.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建一个链表"><span class="nav-number">5.1.</span> <span class="nav-text">创建一个链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双向链表"><span class="nav-number">5.2.</span> <span class="nav-text">双向链表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#集合"><span class="nav-number">6.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#集合操作"><span class="nav-number">6.1.</span> <span class="nav-text">集合操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字典和散列表"><span class="nav-number">7.</span> <span class="nav-text">字典和散列表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字典"><span class="nav-number">7.1.</span> <span class="nav-text">字典</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建一个字典"><span class="nav-number">7.1.1.</span> <span class="nav-text">创建一个字典</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#散列表"><span class="nav-number">7.1.2.</span> <span class="nav-text">散列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建一个散列表"><span class="nav-number">7.1.3.</span> <span class="nav-text">创建一个散列表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#树"><span class="nav-number">8.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#树的相关术语"><span class="nav-number">8.1.</span> <span class="nav-text">树的相关术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树和二叉搜索树"><span class="nav-number">8.2.</span> <span class="nav-text">二叉树和二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树的遍历"><span class="nav-number">8.3.</span> <span class="nav-text">树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#中序遍历"><span class="nav-number">8.3.1.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#先序遍历"><span class="nav-number">8.3.2.</span> <span class="nav-text">先序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后序遍历"><span class="nav-number">8.3.3.</span> <span class="nav-text">后序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#搜索树中的值"><span class="nav-number">8.3.4.</span> <span class="nav-text">搜索树中的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#搜索最小值和最大值"><span class="nav-number">8.3.5.</span> <span class="nav-text">搜索最小值和最大值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#搜索特定值"><span class="nav-number">8.3.6.</span> <span class="nav-text">搜索特定值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#移除一个节点"><span class="nav-number">8.4.</span> <span class="nav-text">移除一个节点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#图"><span class="nav-number">9.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#图的相关术语"><span class="nav-number">9.1.</span> <span class="nav-text">图的相关术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有向图和无向图"><span class="nav-number">9.2.</span> <span class="nav-text">有向图和无向图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图的表示"><span class="nav-number">9.3.</span> <span class="nav-text">图的表示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#邻接矩阵"><span class="nav-number">9.4.</span> <span class="nav-text">邻接矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#邻接表"><span class="nav-number">9.5.</span> <span class="nav-text">邻接表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建图类"><span class="nav-number">9.6.</span> <span class="nav-text">创建图类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表的遍历"><span class="nav-number">9.7.</span> <span class="nav-text">表的遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#广度优先算法"><span class="nav-number">9.8.</span> <span class="nav-text">广度优先算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-BFS-寻找最短路径"><span class="nav-number">9.8.1.</span> <span class="nav-text">使用 BFS 寻找最短路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深度优先搜索"><span class="nav-number">9.8.2.</span> <span class="nav-text">深度优先搜索</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序和搜索算法"><span class="nav-number">10.</span> <span class="nav-text">排序和搜索算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#排序算法"><span class="nav-number">10.1.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#冒泡排序"><span class="nav-number">10.1.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择排序"><span class="nav-number">10.1.2.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入排序"><span class="nav-number">10.1.3.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并归排序"><span class="nav-number">10.1.4.</span> <span class="nav-text">并归排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速排序"><span class="nav-number">10.1.5.</span> <span class="nav-text">快速排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#算法知识补充"><span class="nav-number">11.</span> <span class="nav-text">算法知识补充</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#递归"><span class="nav-number">11.1.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-调用栈大小限制"><span class="nav-number">11.1.1.</span> <span class="nav-text">JavaScript 调用栈大小限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#斐波那契数列"><span class="nav-number">11.1.2.</span> <span class="nav-text">斐波那契数列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态规划"><span class="nav-number">11.1.3.</span> <span class="nav-text">动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大-O-表示法"><span class="nav-number">11.1.4.</span> <span class="nav-text">大 O 表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解大-O-表示法"><span class="nav-number">11.1.5.</span> <span class="nav-text">理解大 O 表示法</span></a></li></ol></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">H</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html>