<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="React,"><meta name="description" content="React in patterns 观看笔记"><meta name="keywords" content="React"><meta property="og:type" content="article"><meta property="og:title" content="React详细介绍"><meta property="og:url" content="https://github.com/HiMrHu/H.git/2018/04/22/React详细介绍/index.html"><meta property="og:site_name" content="胡先生"><meta property="og:description" content="React in patterns 观看笔记"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2020-05-04T05:06:36.935Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="React详细介绍"><meta name="twitter:description" content="React in patterns 观看笔记"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://github.com/HiMrHu/H.git/2018/04/22/React详细介绍/"><title>React详细介绍 | 胡先生</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">胡先生</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://github.com/HiMrHu/H.git/2018/04/22/React详细介绍/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="H"><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="胡先生"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">React详细介绍</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-22T16:13:06+00:00">2018-04-22</time></span></div></header><div class="post-body" itemprop="articleBody"><p><a href="https://krasimir.gitbooks.io/react-in-patterns/content/" target="_blank" rel="noopener">React in patterns</a> 观看笔记</p><a id="more"></a><h1 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h1><p>每个 React 组件就像一个独立运行的小系统，他有自己的输入和输出，分别讲一下</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>在 React 中是通过 props 进行输入的，就像下面这样的</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Title</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;props.text&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这段是定义 props 类型</span></span><br><span class="line">Title.propTypes = &#123;</span><br><span class="line">  text: PropTypes.string</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这段定了 props 的默认值</span></span><br><span class="line">Title.defaultProps = &#123;</span><br><span class="line">  text: <span class="string">"Hello world"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果这里传了 text 属性，那么就会覆盖上面定义的 text: 'Hello world'，如果没定义 就会text属性就会默认被定义为 text: 'Hello world'</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Title</span> <span class="attr">text</span>=<span class="string">"Hello React"</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>Title</code>组件只有一个 props 属性<code>text</code> ，父组件 <code>App</code> 在调用 <code>&lt;Title/&gt;</code>组件的时候需要提供一个 <code>text</code>属性，除了在组件调用的时候提供 <code>text</code>属性之外，还应该在<code>propsType</code>中定义 <code>text</code>的类型检查，这一步很少有人写，我也没怎么写过，但是在多人协作的情况下显得就比较重要了，在多人协作情况下，如果给了错误的类型属性会导致直接抛出错误，这里还有一个<code>defaultProps</code>这是另外一个比较有用的，可以用它来设置默认的<code>props</code>的值，当调用组件的时候忘了传递相关属性，那么这个默认值显得就比较有用了(学习了)。</p><p>在 React 中没有严格的限制 props 传递的内容，这使得我们可以做一些有意思的事情<code>将一个组件作为参数传递</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SomethingElse</span>(<span class="params">&#123; answer &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>The answer is &#123;answer&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Answer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>42<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// later somewhere in our application</span></span><br><span class="line">&lt;SomethingElse answer=&#123;&lt;Answer /&gt;&#125; /&gt;;</span><br></pre></td></tr></table></figure><p>React 还有一个 <code>props.children</code> 属性，它代表可以访问父组件传递的子组件，例如这样</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Title</span>(<span class="params">&#123; text, children &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">      &#123;text&#125;</span><br><span class="line">      &#123;<span class="comment">/*这里可以拿到父组件传递下来的子组件span */</span>&#125;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Title text="Hello React"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span&gt;community&lt;/</span>span&gt;</span><br><span class="line">    &lt;<span class="regexp">/Title&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>React 里面最明显的输出就是显示一个 <code>HTML</code>，在视觉上，这也是我们想得到的，但是 <code>props</code>可能是任何东西，一个函数、一个字符串、一个数组、等等等等</p><p>在下面例子中，组件接受一个回调函数，将 <code>input</code>的输入通过回调函数输出出去，传递给 <code>App</code>组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NameField</span>(<span class="params">&#123; valueUpdated &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;event</span> =&gt;</span> valueUpdated(event.target.value)&#125; /&gt;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">name</span>: <span class="string">""</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;NameField valueUpdated=&#123;name =&gt; <span class="keyword">this</span>.setState(&#123; name &#125;)&#125; /&gt;</span><br><span class="line">        Name: &#123;<span class="keyword">this</span>.state.name&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在程序中，经常需要一个逻辑入口点，在<code>React</code>中带有一些方便便捷的<code>声明周期方法</code>，可以在不同的时间做一些不同的事情，例如可以在生命周期中触发请求，获得数据资源。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultsPage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 触发请求获得数据</span></span><br><span class="line">    <span class="keyword">this</span>.props.getResults();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.results) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">List</span> <span class="attr">results</span>=<span class="string">&#123;this.props.results&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">LoadingScreen</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将每个 React 组件视为一个黑盒，它有自己的输入输出和声明周期，将由开发者来组成这些盒子，这也是 React 提供的诸多优势之一，易于抽象和撰写。</p><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><p>React 为事件处理提供了一系列属性，该解决方案与标准 DOM 中使用的解决方案几乎相同，但是也有一些差异，比如使用驼峰写法来添加一个事件，但是总体来说还是非常相似的。(这些所有的驼峰写法的事件，都是经过 React 包装的，在这些事件里面调用 this.setState 都是异步的，就是多次的 setState 都会被集中执行)</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> theLogoIsClicked = <span class="function"><span class="params">()</span> =&gt;</span> alert(<span class="string">'Clicked'</span>);</span><br><span class="line"></span><br><span class="line">&lt;Logo onClick=&#123; theLogoIsClicked &#125; /&gt;</span><br><span class="line">&lt;input</span><br><span class="line">  type=<span class="string">'text'</span></span><br><span class="line">  onChange=&#123;event =&gt; theInputIsChanged(event.target.value) &#125; /&gt;</span><br></pre></td></tr></table></figure><p>这样通常我们在包含事件的元素组件中处理事件，就像下面那样，有一个点击事件，每次点击都是运行相同的函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switcher</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this._handleButtonClick&#125;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在JavaScript中没有私有方法这一说，所以有些喜欢加一个下划线来表明方法是私有的，但是在函数名中加下划线也可能过不去eslint代码检查</span></span><br><span class="line">  _handleButtonClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Button is clicked"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，<code>_handleButtonClick</code>是一个函数，那么函数中的<code>this</code>指向哪里？严格模式下是<code>undefined</code>非严格模式下函数内部的<code>this</code>指向<code>window</code>对象，所以要在函数内部使用<code>this</code>需要做点额外的事情具体代码如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方案使用 bind</span></span><br><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>._handleButtonClick.bind(<span class="keyword">this</span>)&#125;&gt;click me&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>但是<code>bind</code>之后每一次点击都会重新生成一个新的函数，更好的方法是在构造函数中绑定，这样只会生成一次</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switcher</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">name</span>: <span class="string">"React in patterns"</span> &#125;;</span><br><span class="line">    <span class="comment">// 在构造函数中进行 bind</span></span><br><span class="line">    <span class="keyword">this</span>._buttonClick = <span class="keyword">this</span>._handleButtonClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this._buttonClick&#125;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _handleButtonClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Button is clicked inside <span class="subst">$&#123;<span class="keyword">this</span>.state.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，又会有另外一个问题，如果有很多事件函数，难道一个一个的在构造函数里面<code>bind</code>？那么可以使用下面这种提案阶段语法。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switcher</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">name</span>: <span class="string">"React in patterns"</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this._buttonClick&#125;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _handleButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Button is clicked inside <span class="subst">$&#123;<span class="keyword">this</span>.state.name&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写 <code>函数名 = () =&gt; {}</code> 这是一种提案阶段语法，但是已经在 <code>Facebook</code>内部大量使用，<code>Facebook</code>承诺如果将来这种语法没能称为标准(板上钉钉会上标准，除非发生灵异事件)，那么会由<code>Facebook</code>提供 babel 插件让开发者可以继续使用。</p><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>React 最大的好处之一就是组合性，举个简单例子，假设有一个程序，有三个 React 组件，<code>App</code> 嵌套 <code>Header</code> 嵌套 <code>Navigation</code>组件</p><p>那么组合这些组件的简单方法就是在合适的地方引用它们</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.jsx</span></span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">"./Header.jsx"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Header.jsx</span></span><br><span class="line"><span class="keyword">import</span> Navigation <span class="keyword">from</span> <span class="string">"./Navigation.jsx"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;Navigation /&gt;</span><br><span class="line">    &lt;<span class="regexp">/header&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Navigation.jsx</span></span><br><span class="line"><span class="regexp">export default function Navigation() &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;nav&gt; ... &lt;/</span>nav&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照这种方法进行组合，会有几个问题</p><ol><li>可能会让别人误认为 <code>App</code> 组件实现了所有功能，没有其他组建了。</li><li>这样写代码很难测试，加入每个组件都有一部分业务逻辑，为了分别测试他们，但是由于这个组件本身引用了另一个组件，这样嵌套的模式，让测试极为繁重。</li></ol><h2 id="使用-React-的-children-API"><a href="#使用-React-的-children-API" class="headerlink" title="使用 React 的 children API"></a>使用 React 的 children API</h2><p>在 React 中，有一个很方便的 <code>children</code>API，通过它可以直接从 props 中读取父组件给他的子组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Header&gt;</span><br><span class="line">      &lt;Navigation /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Header&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default function Header(&#123; children &#125;) &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;header&gt;&#123;children&#125;&lt;/</span>header&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写组件可以很方便的测试<code>Header</code>组件，将<code>Header</code>组件和其他组件隔离开来，不依赖任何其他组件。</p><h2 id="传递一个子组件作为-Porps"><a href="#传递一个子组件作为-Porps" class="headerlink" title="传递一个子组件作为 Porps"></a>传递一个子组件作为 Porps</h2><p>每个 React 组件都会收到 props，对 props 是什么类型，React 并没有任何严格的规定，所以可以让我们传递组件作为 props</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Title = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello there!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> Header = <span class="function"><span class="keyword">function</span>(<span class="params">&#123; title, children &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &#123;title&#125;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/header&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Header title=&#123;&lt;Title /</span>&gt;&#125;&gt;</span><br><span class="line">      &#123;<span class="comment">/* 给title属性传递一个组件作为属性 */</span>&#125;</span><br><span class="line">      &lt;Navigation /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Header&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>给一个属性传递一个组件作为属性值，这种技术非常好用，考虑一个情况，有一个组件可以被多次复用，但是每个引用该组件的地方都需要做一点变化，那么将这个变化的部分写成一个属性，属性接受一个组件作为值。就可以很好的进行复用了。</p><h1 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h1><p>长期一来，高阶组件作为增强 React 组件最流行的方式，运作方式看起来非常像装饰器(关于装饰器，Create-react-app 中为什么不支持，在文档中官方表示说装饰器还没有上标准，而且 babel 也没有正式实现，意思就是还在试验阶段，所以最终装饰器会是什么样子，还不确定，以至于 Facebook 官方并没有采用装饰器，而且装饰器没有办法提供模拟脚本，所以一旦最终的行为与现在不一致，他们将没有办法为用户提供过度。以至于一直不支持)</p><p>在技术方面，高阶组件通常接受我们的原始组件，然后返回增强后的函数或者组件，最小例子如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 定义一个函数，函数接受一个组件作为参数，并且返回一个添加了 props 属性的组件。</span></span><br><span class="line"><span class="keyword">var</span> enhanceComponent = <span class="function"><span class="params">Component</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> OriginalTitle = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">var</span> EnhancedTitle = enhanceComponent(OriginalTitle);</span><br><span class="line"><span class="comment">// 1. 定义一个普通的 App 组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">EnhancedTitle</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高阶组件做的第一件事，就是渲染初始组件，代理传递<code>props</code> 给它是一种很好的做法，这样我们将保留原始组件的输入，这就是这种模式的第一大优势—因为我们控制组件的输入，所以我们可能会发送组件通常无法访问的内容，假设我们有一个<code>OriginalTitle</code>需要的配置设置</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">"path/to/configuration"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> enhanceComponent = <span class="function"><span class="params">Component</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125; <span class="attr">title</span>=<span class="string">&#123;config.appTitle&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> OriginalTitle = <span class="function">(<span class="params">&#123; title &#125;</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">var</span> EnhancedTitle = enhanceComponent(OriginalTitle);</span><br></pre></td></tr></table></figure><p>这个高阶组件，将 <code>OriginalTitle</code>组件需要接受一个<code>title</code>属性的细节，放在了高阶函数内部实现的，外部也不知道<code>OriginalTitle</code>组件的 <code>title</code>属性值来自 <code>config.appTitle</code> 对象中，这是一种代码隔离，有助于组件的测试，因为可以轻松创建模拟</p><p>这种模式的另外一个特点，是可以让我们有一个很好的缓冲区来添加新的逻辑，例如，如果将<code>OriginalTitle</code>组件的某个属性值需要从服务器中获取，那么就可以使用高阶函数，并且在生命周期中进行请求</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 定义一个函数，函数接受一个参数，返回一个 React 组件，并且在组件生命周期内进行请求，然后更新到 state里面</span></span><br><span class="line"><span class="keyword">var</span> enhanceComponent = <span class="function"><span class="params">Component</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.state = &#123; <span class="attr">remoteTitle</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      fetchRemoteData(<span class="string">"path/to/endpoint"</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123; <span class="attr">remoteTitle</span>: data.title &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面进行渲染，当 state 被更新，组件就会重新渲染，这样就传递给了参数组件里面了</span></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Component</span><br><span class="line">          &#123;...this.props&#125;</span><br><span class="line">          title=&#123;config.appTitle&#125;</span><br><span class="line">          remoteTitle=&#123;<span class="keyword">this</span>.state.remoteTitle&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义一个普通的函数组件</span></span><br><span class="line"><span class="keyword">var</span> OriginalTitle = <span class="function">(<span class="params">&#123; title, remoteTitle &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    &#123;title&#125;</span><br><span class="line">    &#123;remoteTitle&#125;</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 3. 调用高阶函数并将上面的组件传做参数</span></span><br><span class="line"><span class="regexp">var EnhancedTitle = enhanceComponent(OriginalTitle);</span></span><br></pre></td></tr></table></figure><p>这样，<code>OriginalTitle</code> 组件将会直到自己有两个属性，但是不用关系数据从哪里来</p><h2 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h2><p>而最近，React 社区开始流行一种新的方案， <code>render props</code>，在上面的例子中 <code>children</code>是一个 React 的组件，然而，<code>render props</code>中传递的是 <code>jsx表达式</code>，举个例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserName</span>(<span class="params">&#123; children &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;b&gt;&#123;children.lastName&#125;&lt;<span class="regexp">/b&gt;,&#123;children.firstName&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = &#123;</span><br><span class="line">    firstName: <span class="string">"Krasimir"</span>,</span><br><span class="line">    lastName: <span class="string">"Tsonev"</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">UserName</span>&gt;</span>&#123;user&#125;<span class="tag">&lt;/<span class="name">UserName</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个有点意思，以前从来没这么写过，有点意思。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个组件并且遍历 todos 数组，调用 children 函数返回要渲染的 带b标签的 或者不带 标签的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoList</span>(<span class="params">&#123; todos, children &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;section className=<span class="string">"main-section"</span>&gt;</span><br><span class="line">      &lt;ul className=<span class="string">"todo-list"</span>&gt;</span><br><span class="line">        &#123;todos.map(<span class="function">(<span class="params">todo, i</span>) =&gt;</span> (</span><br><span class="line">          &lt;li key=&#123;i&#125;&gt;&#123;children(todo)&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ App组件</span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 定义一个数组</span></span><br><span class="line"><span class="regexp">  const todos = [</span></span><br><span class="line"><span class="regexp">    &#123; label: "Write tests", status: "done" &#125;,</span></span><br><span class="line"><span class="regexp">    &#123; label: "Sent report", status: "progress" &#125;,</span></span><br><span class="line"><span class="regexp">    &#123; label: "Answer emails", status: "done" &#125;</span></span><br><span class="line"><span class="regexp">  ];</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 定义一个函数，返回布尔值</span></span><br><span class="line"><span class="regexp">  const isCompleted = todo =&gt; todo.status === "done";</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 调用 TodoList 组件，并且传一个 函数作为 children</span></span><br><span class="line"><span class="regexp">    &lt;TodoList todos=&#123;todos&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &#123;todo =&gt; (isCompleted(todo) ? &lt;b&gt;&#123;todo.label&#125;&lt;/</span>b&gt; : todo.label)&#125;</span><br><span class="line">    &lt;<span class="regexp">/TodoList&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>慢慢看一下还是可以看懂的，写这样的代码有点抽象了</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoList</span>(<span class="params">&#123; todos, render &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;section className=<span class="string">"main-section"</span>&gt;</span><br><span class="line">      &lt;ul className=<span class="string">"todo-list"</span>&gt;</span><br><span class="line">        &#123;todos.map(<span class="function">(<span class="params">todo, i</span>) =&gt;</span> (</span><br><span class="line">          &lt;li key=&#123;i&#125;&gt;&#123;render(todo)&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">return (</span></span><br><span class="line"><span class="regexp">  &lt;TodoList</span></span><br><span class="line"><span class="regexp">    todos=&#123;todos&#125;</span></span><br><span class="line"><span class="regexp">    render=&#123;todo =&gt; (isCompleted(todo) ? &lt;b&gt;&#123;todo.label&#125;&lt;/</span>b&gt; : todo.label)&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这是另外一种，通过定义一个 render 属性，值是一个函数，并且在 TodoList 组件内部调用 render 传的函数实现渲染，这种模式比上面哪个可读性高多了</p><p>通过组合，我们可以做一些好玩的事情比如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataProvider</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">data</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">    <span class="comment">// 上面定义 date 为 null ，下面定义一个定时器 五秒之后更新 state</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123; <span class="attr">data</span>: <span class="string">"Hey there!"</span> &#125;), <span class="number">5000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 判断 date 是否为空，如果为空则不渲染</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.data === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 不为空则调用 props 的 render 函数并且传入参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">section</span>&gt;</span>&#123;this.props.render(this.state.data)&#125;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里调用并传入 render 属性，值为一个函数接受一个参数 返回一个标签（这个参数好像没什么意义</span></span><br><span class="line">&lt;DataProvider render=&#123;data =&gt; <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The data is here!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125; /&gt;;</span><br></pre></td></tr></table></figure><h1 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h1><p>受控组件和非受控组件常用语用户输入，例如 下面就是一个 受控组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">value</span>: <span class="string">"hello"</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 给input 组件传入 value 属性值为 state</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码确实是一个受控组件，但是用户无法更改<code>input</code>的值，因为的值指定的是一个固定的<code>state</code>这个<code>state</code>并不会更新永远都是<code>hello</code>，为了使值可以发生变化，需要添加<code>onChange</code>事件来更新和处理用户输入</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">value</span>: <span class="string">"hello"</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;input type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.value&#125; onChange=&#123;<span class="keyword">this</span>._change&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  _handleInputChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">value</span>: e.target.value &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样添加了一个 <code>onChange</code>事件 并且指向 <code>_handleInputChange</code>函数，并且更新 state 刷新 UI 更新 input 的 value</p><p>##非受控组件</p><p>另一种是非受控组件，一般用于用户输入的值不重要不需要，只需要提供 <code>input</code>的 <code>defaultValue</code>属性即可，之后由浏览器保存用户输入值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">value</span>: <span class="string">"hello"</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">defaultValue</span>=<span class="string">&#123;this.state.value&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们无法获取用户输入，这个组件的值更新没有更新我们都无法得知，也不知道用户输入了什么，为了直到用户输入了什么我们必须使用<code>refs</code>来获取真实<code>DOM</code>读取用户输入。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">value</span>: <span class="string">"hello"</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        defaultValue=&#123;<span class="keyword">this</span>.state.value&#125;</span><br><span class="line">        onChange=&#123;<span class="keyword">this</span>._change&#125;</span><br><span class="line">        ref=&#123;input =&gt; (<span class="keyword">this</span>.input = input)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  _handleInputChange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">value</span>: <span class="keyword">this</span>.input.value &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，就不做过多解释。尽量不要在 React 中使用非受控模式</p><h1 id="展示组件和容器组件"><a href="#展示组件和容器组件" class="headerlink" title="展示组件和容器组件"></a>展示组件和容器组件</h1><p>展示组件和容器组件也被称为，木偶组件和智能组件，这些概念对初学者很不友好，在初学者比较常见的一个问题就是我的数据应该放在哪里，如果进行通信，而这个问题的答案往往是不同统一的，只有经过大量的练习拥有了充足的经验之后，才可能有答案，但是对于这种问题是有一个被广泛使用的模式的，有助于组织基于 React 的应用程序，那就是将组件分解为 <code>展示组件</code>和<code>容器组件</code></p><p>从一个简单的例子开始说明，然后将组件分解为<code>展示组件</code>和<code>容器组件</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">time</span>: <span class="keyword">this</span>.props.time &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="keyword">this</span>._formatTime(<span class="keyword">this</span>.state.time);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;</span><br><span class="line">        &#123; time.hours &#125; : &#123; time.minutes &#125; : &#123; time.seconds &#125;</span><br><span class="line">      &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    this._interval = setInterval(this._update, 1000);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  componentWillUnmount() &#123;</span></span><br><span class="line"><span class="regexp">    clearInterval(this._interval);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  _formatTime(time) &#123;</span></span><br><span class="line"><span class="regexp">    var [ hours, minutes, seconds ] = [</span></span><br><span class="line"><span class="regexp">      time.getHours(),</span></span><br><span class="line"><span class="regexp">      time.getMinutes(),</span></span><br><span class="line"><span class="regexp">      time.getSeconds()</span></span><br><span class="line"><span class="regexp">    ].map(num =&gt; num &lt; 10 ? '0' + num : num);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    return &#123; hours, minutes, seconds &#125;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  _updateTime = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    this.setState(&#123;</span></span><br><span class="line"><span class="regexp">      time: new Date(this.state.time.getTime() + 1000)</span></span><br><span class="line"><span class="regexp">    &#125;);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Clock time=&#123; new Date() &#125;/</span>&gt;, ...);</span><br></pre></td></tr></table></figure><p>在例子中，显示出档期内的时间值，通过<code>setInterval</code>每秒更新状态，而且组件会被重新渲染，使它看起来更像一个时钟</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在这个组件中我们做了很多件事情，使它看起来很臃肿，不方便维护</p><ul><li>组件会自己改变自身的状态，改变组件内部的 <code>time</code>可能并不是一个好的主意，因为只有计时器才知道当前值，如果系统的另一部分依赖于这些数据，则很难分享</li><li>_formatTime 函数其实在做两件事，首先从日期中提取所需的信息，并且确保这些值始终以两位数字表示，如果它不提取函数的一部分，那么就没什么问题，但是正是由于它引用了另外的函数，那么他就会强行绑定在当前环境</li></ul><h3 id="提取容器组件"><a href="#提取容器组件" class="headerlink" title="提取容器组件"></a>提取容器组件</h3><p>容器组件了解数据，知道数据来自哪里，知道业务逻辑的细节，接受信息并将其格式化，使其容易被展示组件使用，大佬们经常使用<code>class</code>来创建容器，因为可以提供一个缓冲区间，可以在其中插入自定义逻辑</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clock/index.js</span></span><br><span class="line"><span class="keyword">import</span> Clock <span class="keyword">from</span> <span class="string">"./Clock.jsx"</span>; <span class="comment">// &lt;-- that's the presentational component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ClockContainer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">time</span>: props.time &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Clock</span> &#123;<span class="attr">...this._extract</span>(<span class="attr">this.state.time</span>)&#125; /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>._interval = setInterval(<span class="keyword">this</span>._update, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>._interval);</span><br><span class="line">  &#125;</span><br><span class="line">  _extract(time) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      hours: time.getHours(),</span><br><span class="line">      minutes: time.getMinutes(),</span><br><span class="line">      seconds: time.getSeconds()</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  _updateTime = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      time: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">this</span>.state.time.getTime() + <span class="number">1000</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ClockContainer</code>组件初始一个<code>state</code> 并且在 <code>componentDidMount</code>生命周期中调用<code>setInterval</code>每秒更新<code>state</code>，并且最后将毫秒数传给<code>Clock</code>组件</p><h3 id="展示组件"><a href="#展示组件" class="headerlink" title="展示组件"></a>展示组件</h3><p>展示组件只关心如何展现 UI 部分，这些组件不需要逻辑函数，也没有依赖，通常时限为<code>无状态组件</code>，表示他们内部不保留任何状态</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> [hours, minutes, seconds] = [</span><br><span class="line">    props.hours,</span><br><span class="line">    props.minutes,</span><br><span class="line">    props.seconds</span><br><span class="line">  ].map(<span class="function"><span class="params">num</span> =&gt;</span> (num &lt; <span class="number">10</span> ? <span class="string">"0"</span> + num : num));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">      &#123;hours&#125; : &#123;minutes&#125; : &#123;seconds&#125;</span><br><span class="line">    &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>数据全靠<code>父组件传递</code>，本身只负责渲染 UI 部分</p><h3 id="这样做的好处"><a href="#这样做的好处" class="headerlink" title="这样做的好处"></a>这样做的好处</h3><p>这样做有什么好处，好处就是可以提高组件的可重用性，减少组件之间的耦合状态，将<code>逻辑</code>与<code>UI</code>分离开来，互相之间没有强耦合关系，逻辑不管 UI，同理 UI 也不关心逻辑实现。</p><h1 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h1><p>单向数据流是一种和 React 十分契合的一种模式，围绕这种模式，数据是单向的，即组件不会修改接收到的数据，只会监听这些数据变化，从而得到新的值，但是不会修改实际的数据，这个更新发生在另一个地方的另一个机制，并且该组件将会被重新渲染，并赋予新的值。</p><p>举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switcher</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">flag</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>._onButtonClick = <span class="function"><span class="params">e</span> =&gt;</span></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        flag: !<span class="keyword">this</span>.state.flag</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>._onButtonClick&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.flag ? <span class="string">"lights on"</span> : <span class="string">"lights off"</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ... and we render it</span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;Switcher /</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时只有<code>Switcher</code>组件内部持有数据，也就是说<code>Switcher</code>是唯一知道<code>flag</code>的地方</p><p>那么接下来将这个 <code>flag</code>传递给别的对象：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Store = &#123;</span><br><span class="line">  _flag: <span class="literal">false</span>,</span><br><span class="line">  <span class="keyword">set</span>: value =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>._flag = value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>: () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._flag;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switcher</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">flag</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>._onButtonClick = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">flag</span>: !<span class="keyword">this</span>.state.flag &#125;, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.props.onChange(<span class="keyword">this</span>.state.flag);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>._onButtonClick&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.flag ? <span class="string">"lights on"</span> : <span class="string">"lights off"</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;Switcher onChange=&#123;Store.set&#125; /</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过<code>Switcher</code>的<code>button的onClic</code>事件触发修改 flag，并且通过 <code>props</code>传下来的 <code>onChange</code>属性的值是一个函数，调用这个函数成功修改 <code>Store</code>对象的值。</p><p>思考一个问题，如果<code>Store</code>对象，被其他组件修改了，这里就发生了数据不同意 <code>Store</code>已经被更改了，<code>Switcher</code>组件内部的<code>flag</code>并没有更改，这就导致了数据不统一。</p><p>而单项数据流就是为了解决这个问题，他消除了状态存于多处，而导致的数据不统一，为了实现这一点，我们稍微对<code>Store</code>稍微进行一下调整</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Store = &#123;</span><br><span class="line">  <span class="comment">// 通知队列</span></span><br><span class="line">  _handlers: [],</span><br><span class="line">  <span class="comment">// flag的值</span></span><br><span class="line">  _flag: <span class="string">""</span>,</span><br><span class="line">  <span class="comment">// 将通知对象添加进队列以便数据更改进行通知</span></span><br><span class="line">  subscribe: <span class="function"><span class="params">handler</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._handlers.push(handler);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: value =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>._flag = value;</span><br><span class="line">    <span class="keyword">this</span>._handlers.forEach(<span class="function"><span class="params">handler</span> =&gt;</span> handler(value));</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>: () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._flag;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是一个简单的订阅通知模式，然后更新 App 组件，以便每次 Store 更改的时候重新渲染它：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// 定义初始 state</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">value</span>: Store.get() &#125;;</span><br><span class="line">    <span class="comment">// 将 App 的 setState 添加到带通知队列内Store._handlers 从 [] 变为了 [(value) =&gt; &#123;this.setState(&#123;value&#125;)&#125;]，等数据发生变化的时候执行队列函数，就可以更新 App 的 state 从而引发重新渲染</span></span><br><span class="line">    Store.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123; value &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Switcher value=&#123;<span class="keyword">this</span>.state.value&#125; onChange=&#123;Store.set.bind(Store)&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>由于存在了这种变化，<code>Switcher</code>变得非常简单，因此可以将<code>Switcher</code>写成一个无状态组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Switcher</span>(<span class="params">&#123; value, onChange &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;e =&gt; onChange(!value)&#125;&gt;</span><br><span class="line">      &#123;value ? <span class="string">"lights on"</span> : <span class="string">"lights off"</span>&#125;</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;Switcher value=&#123;Store.get()&#125; onChange=&#123;Store.set&#125; /</span>&gt;;</span><br></pre></td></tr></table></figure><p>这种单向的数据模式，使得开发变得更加容易，无需担心数据的不统一，希望可以通过这个例子了解一下单向数据模式。</p><h1 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h1><p>作者迷恋于简化代码，但是并不是说越小越好，因为减少代码并不意味着更加易用，同时作者相信软件行业的很大一部分问题来自不必要的复杂性，复杂性是自己抽象的结果，程序员喜欢抽象，喜欢把东西放在黑盒内，并期望这些盒子能够一起工作，</p><p>Flux 是构建用户界面体系的设计模式，它是由 Facebook 在 F8 会议上退出的，从那之后，很多公司采纳了这个想法，这事故是构建前端应用程序的一个很好的模式，Flux 经常和 React 一起使用，这种模式简单而灵活，这种模式有助于更快的创建应用程序，同时保持代码组织良好</p><p>流程如下</p><p>Views —&gt; 触发 action —&gt; 通过 dispatch —&gt; 更新 Stores —&gt; 而 Stores 的更新会引起 View 重新渲染</p><p>这种模式中的最主要的部分是 dispatch ，它充当系统中所有实践的中心， 它的工作是接 action 并且传递给 Store，并通过内部状态/数据做出反应，这种变化触发了对 React 组件的重新渲染</p><p>这些 action 是从 View 或者其他部分进入 dispatch ，例如 HTTP 请求结束收到结果会触发一个 action ，说明请求成功。</p><h2 id="dispatcher"><a href="#dispatcher" class="headerlink" title="dispatcher"></a>dispatcher</h2><p>在大多情况下，都需要一个 dispatcher ，它将作为与其他部分之间的沟通部分，dispatcher 需要知道两件事情，action 和 Store，并且将这些 action 转发给 Store</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Dispatcher = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    _stores: [],</span><br><span class="line">    register: <span class="function"><span class="keyword">function</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>._stores.push(&#123; <span class="attr">store</span>: store &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    dispatch: <span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._stores.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._stores.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">          entry.store.update(action);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里向 Store 中存在一个 <code>update</code>方法，如果这个方法不存在则抛出一个错误</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">register: <span class="function"><span class="keyword">function</span> (<span class="params">store</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!store || !store.update) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'你需要为 Store 提供一个拥有 `update` 方法.'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._stores.push(&#123; <span class="attr">store</span>: store &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmmmmm 下面字谷歌翻译也看不懂。。。。</p><h2 id="更新-View-和-Store"><a href="#更新-View-和-Store" class="headerlink" title="更新 View 和 Store"></a>更新 View 和 Store</h2><p>接下来合乎逻辑的步骤是<code>View</code> 链接到 <code>Store</code>，以便在 <code>Store</code>放生变化的时候 <code>View</code>可以进行重新渲染</p><h3 id="使用-Flux-辅助函数"><a href="#使用-Flux-辅助函数" class="headerlink" title="使用 Flux 辅助函数"></a>使用 Flux 辅助函数</h3><p>这里可以使用 <code>Flux</code>提供的一个辅助函数来完成链接功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Framework.attachToStore(view, store);</span><br></pre></td></tr></table></figure><p>通过辅助函数来链接<code>view</code>和<code>store</code></p><p>但是作者不喜欢这种直接调用赋值函数的方法，所以下面将介绍如果自己实现这个方法</p><p>###使用 mixin</p><p>使用 React 的 mixin 进行构建(mixin 官方已经弃用了)</p><p>官方说明：</p><blockquote><p><strong>注意：</strong></p><p>ES6 在没有任何混合支持的情况下发布。因此，当您使用 ES6 类的 React 时，不支持 mixin。</p><p><strong>我们在使用 mixins 的代码库中也发现了很多问题，并且不建议在新代码中使用它们。</strong></p><p>本部分仅供参考</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> View = React.createClass(&#123;</span><br><span class="line">  mixins: [Framework.attachToStore(store)]</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这是定义现有 React 组件行为的好方法(createClass 是使用 es5 语法书写 React 的方法)</p><p>emmmm 。。。作者不喜欢 mixin 因为它用不可预测的方式修改组件，所以放弃了这个选项</p><h3 id="使用-context"><a href="#使用-context" class="headerlink" title="使用 context"></a>使用 context</h3><p>那么 mixin 不能用那就只能使用另一个可行的技术是 React 的 context API，这是一种可以穿透组件传递状态的方法，而不需要在每个组件中层层传递，Facebook 在数据必须深入嵌套组件的情况下建议使用 context</p><h3 id="高阶组件概念"><a href="#高阶组件概念" class="headerlink" title="高阶组件概念"></a>高阶组件概念</h3><p>高阶组件借鉴了 <a href="https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775" target="_blank" rel="noopener">introduced</a> 代码片段(这个地址好像要科学上网)作者 Sebastian,它是关于创造一个返回包装过的组件，做这件事它将有机会添加属性和引入其他逻辑，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是个高阶函数不用讲了吧</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">attachToStore</span>(<span class="params">Component, store, consumer</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 es5 语法创建一个 react 的 class</span></span><br><span class="line">  <span class="keyword">const</span> Wrapper = React.createClass(&#123;</span><br><span class="line">    <span class="comment">// 定义初始 state 下面的我也不太懂。。抱歉</span></span><br><span class="line">    getInitialState() &#123;</span><br><span class="line">      <span class="keyword">return</span> consumer(<span class="keyword">this</span>.props, store);</span><br><span class="line">    &#125;,</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      store.onChangeEvent(<span class="keyword">this</span>._handleStoreChange);</span><br><span class="line">    &#125;,</span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      store.offChangeEvent(<span class="keyword">this</span>._handleStoreChange);</span><br><span class="line">    &#125;,</span><br><span class="line">    _handleStoreChange() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.isMounted()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(consumer(<span class="keyword">this</span>.props, store));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...this.state</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> Wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想将<code>Store</code>附加到 <code>store</code>，同时传入一个<code>consumer</code>函数说明应该提取哪些<code>Store</code>的状态并且分发到<code>view</code>，上述功能的简单使用可以是</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProfilePage = connectToStores(MyView, store, (props, store) =&gt; (&#123;</span><br><span class="line">  data: store.get(<span class="string">'key'</span>)</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>真是巧妙的代码，反正我写不出来，我理解起来都需要一会，真是巧妙。</p><p>这是一个有趣的模式，因为它改变了职责，从<code>Store</code>中获取数据的<code>view</code>，而不是从<code>Store</code>中推送数据到<code>view</code>，当然这也有他的缺点，这种方法的缺点就是还需要一个包装组件参与其中</p><h3 id="作者的选择"><a href="#作者的选择" class="headerlink" title="作者的选择"></a>作者的选择</h3><p>上面的最后一个选项是高阶组件，它非常接近作者正在探索的内容</p><p>到目前为止仅在该<code>register</code>方法中与<code>Store</code>进行交互</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">register: <span class="function"><span class="keyword">function</span> (<span class="params">store</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!store || !store.update) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'你应该为store提供一个 `update` 方法.'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._stores.push(&#123; <span class="attr">store</span>: store &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>register</code> 保持对<code>dispatcher</code>内的<code>store</code>的引用，但是，<code>register</code>他可能会返回一个用户接受的<code>subscriber</code></p><p>决定将整个<code>store</code>放在<code>consumer</code>里面，而不是在<code>store</code>中保存数据，就像高阶组件一样，View 应该使用<code>stroe</code>的<code>getter</code>方法来说明他需要什么，这使得<code>store</code>非常简单</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register 接受一个 Store对象，对象需要有一个 update方法如果不存在就抛出异常</span></span><br><span class="line">register: <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 用箭头函数绑定this</span></span><br><span class="line">  <span class="keyword">if</span> (!store || !store.update) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"你应该为store 提供一个 `update` 方法."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> consumers = []; <span class="comment">// 通知列表</span></span><br><span class="line">    <span class="keyword">var</span> subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">consumer</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 待通知对象</span></span><br><span class="line">      consumers.push(consumer); <span class="comment">// 添加到队列</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._stores.push(&#123; <span class="attr">store</span>: store &#125;);</span><br><span class="line">    保存store;</span><br><span class="line">    <span class="keyword">return</span> subscribe; <span class="comment">// 返回添加通知函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据原则，Store 会根据行为改变状态，在<code>update</code>方法中发送<code>action</code>，也可以发送一个<code>change</code>函数，调用这个函数触发观察者模式。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">register: <span class="function"><span class="keyword">function</span> (<span class="params">store</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!store || !store.update) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'You should provide a store that has an `update` method.'</span></span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> consumers = [];</span><br><span class="line">    <span class="keyword">var</span> change = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      consumers.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">l</span>) </span>&#123;</span><br><span class="line">        l(store);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> subscribe = <span class="function"><span class="keyword">function</span> (<span class="params">consumer</span>) </span>&#123;</span><br><span class="line">      consumers.push(consumer);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._stores.push(&#123; <span class="attr">store</span>: store, <span class="attr">change</span>: change &#125;);</span><br><span class="line">    <span class="keyword">return</span> subscribe;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;,</span><br><span class="line">dispatch: <span class="function"><span class="keyword">function</span> (<span class="params">action</span>) </span>&#123; <span class="comment">// dispatch 函数接受一个参数action</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._stores.length &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果store不为空</span></span><br><span class="line">    <span class="keyword">this</span>._stores.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">entry</span>) </span>&#123;<span class="comment">// 调用遍历函数给store中每个对象添加一个update方法用来发送action和触发观察者模式函数</span></span><br><span class="line">      entry.store.update(action, entry.change);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最常用的方法就是使用<code>Store</code>的初始状态渲染<code>View</code>,这意味着至少需要一次初始化，可以通过下面的<code>subscribe</code>方法完成</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">consumer, noInit</span>) </span>&#123;</span><br><span class="line">  consumers.push(consumer);</span><br><span class="line">  !noInit ? consumer(store) : <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看不太懂，有点绕</p><p>下面是最终版本</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Dispatcher = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    _stores: [], <span class="comment">// stores 对象</span></span><br><span class="line">    register: <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 返回一个函数接受原始 store 对象作为参数，并且判断其中有没有update方法</span></span><br><span class="line">      <span class="keyword">if</span> (!store || !store.update) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">          <span class="string">"You should provide a store that has an `update` method"</span></span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> consumers = []; <span class="comment">// 待通知队列</span></span><br><span class="line">        <span class="keyword">var</span> change = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 给每个待通知对象都传入一个store</span></span><br><span class="line">          consumers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">l</span>) </span>&#123;</span><br><span class="line">            l(store);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> subscribe = <span class="function">(<span class="params">consumer, noInit</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 订阅对象接受一个待通知函数和是否进行初始化布尔值</span></span><br><span class="line">          consumers.push(consumer);</span><br><span class="line">          !noInit ? consumer(store) : <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>._stores.push(&#123; <span class="attr">store</span>: store, <span class="attr">change</span>: change &#125;); <span class="comment">// 不太懂</span></span><br><span class="line">        <span class="keyword">return</span> subscribe;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    dispatch: <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// dispatch</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._stores.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断Store是否为空</span></span><br><span class="line">        <span class="keyword">this</span>._stores.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 调用被通知对象函数通知更新</span></span><br><span class="line">          entry.store.update(action, entry.change);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>action 定义为右两个属性，<code>type</code>，<code>payload</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">'USER_LOGIN_REQUEST'</span>,</span><br><span class="line">  payload: &#123;</span><br><span class="line">    username: <span class="string">'...'</span>,</span><br><span class="line">    password: <span class="string">'...'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>action</code> 包含了两个对象分别是<code>type</code>和<code>payload</code>，在一些情况下<code>payload</code>可以是空的</p><p>创建一个创建一个函数，用来构造 <code>action</code>对象，例如</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createAction = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!type) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Please, provide action's type."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> dispatcher.dispatch(&#123;</span><br><span class="line">        type: type,</span><br><span class="line">        payload: payload</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用两次，第一次调用传入<code>type</code>第二次调用传入<code>payload</code></p><p>这个函数有几个好处</p><ul><li>不再需要记住<code>action</code>的具体类型，仅仅需要传入一个<code>type</code></li><li>不在需要显式的调用<code>dispatch</code>函数</li><li>不必要亲自处理每个细节，而是将过程封装为一个函数，这个函数会描述整个过程</li></ul><p>这个也影响到了接下来流行的 redux</p><p>最终部分代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createSubscriber = <span class="function"><span class="keyword">function</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dispatcher.register(store);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Dispatcher = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    _stores: [],</span><br><span class="line">    register: <span class="function"><span class="keyword">function</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!store || !store.update) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">          <span class="string">"You should provide a store that has an `update` method"</span></span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> consumers = [];</span><br><span class="line">        <span class="keyword">var</span> change = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          consumers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">l</span>) </span>&#123;</span><br><span class="line">            l(store);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">consumer, noInit</span>) </span>&#123;</span><br><span class="line">          consumers.push(consumer);</span><br><span class="line">          !noInit ? consumer(store) : <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>._stores.push(&#123; <span class="attr">store</span>: store, <span class="attr">change</span>: change &#125;);</span><br><span class="line">        <span class="keyword">return</span> subscribe;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    dispatch: <span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._stores.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._stores.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">          entry.store.update(action, entry.change);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  create: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dispatcher = Dispatcher();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      createAction: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!type) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Please, provide action's type."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dispatcher.dispatch(&#123;</span><br><span class="line">              type: type,</span><br><span class="line">              payload: payload</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      createSubscriber: <span class="function"><span class="keyword">function</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dispatcher.register(store);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>整个过程真的巧妙，厉害</p><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p>redux 是一个状态管理库，在 <code>React</code>中管理全局数据，是<code>Flux</code>的进阶版</p><p>在<code>redux</code>中由<code>React</code>部分触发<code>action</code>，到达<code>Store</code>，最后由<code>reducer</code>更新<code>Store</code></p><p>和<code>Flux</code>最大的区别就是<code>Redux</code>只有一个<code>Store</code>，最后决定数据的是由<code>reducer</code>来决定的，<code>reducer</code>是一个纯函数，一旦<code>Store</code>接收到一个<code>action</code>就会挨个匹配<code>reducer</code>并且调用函数进行更新数据</p><p>这个理念非常线性，而且遵循<code>单向数据流</code>接下来介绍一些<code>redux</code>的工作模式</p><h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p>在<code>Redux</code>中的和<code>flux</code>类似，<code>action</code>都是一个具有<code>type</code>的对象，这个对象中的其他所有数据都和这个模式无关</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CHANGE_VISIBILITY = <span class="string">"CHANGE_VISIBILITY"</span>; <span class="comment">// 常理中全大写的字符串是静态的固定的</span></span><br><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  type: CHANGE_VISIBILITY,</span><br><span class="line">  visible: <span class="literal">false</span> <span class="comment">// 携带的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当需要<code>dispatch</code>一个<code>action</code>的时候，都必须要使用这个对象，但是一遍一遍抄太枯燥了，这就是为什么有<code>createAction</code>，这个<code>createAction</code>是一个函数，返回一个对象。</p><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>在<code>Redux</code>中，为我们提供了一个<code>createStore</code>函数用来创建<code>Store</code>使用方法如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line">createStore([reducer],[initial state],[enhancer])</span><br></pre></td></tr></table></figure><p>createStore 的第一个参数<code>reducer</code>是一个接受当前<code>action</code>并且返回新的状态的函数，第二个参数是<code>初始化状态</code>，这是一个非常方便定义初始状态的地方，第三个参数是<code>Redux</code>添加第三方中间件的，可以用来添加一些插件，比如日至打印，异步处理等中间件。</p><p>一旦创建<code>Store</code>之后，<code>Store</code>就有了四种方法，<code>getState</code>，<code>dispatch</code>，<code>subscribe</code>，和<code>replaceReducer</code>其中最重要的是<code>dispatch</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispath(changeVisibility(<span class="literal">false</span>));</span><br></pre></td></tr></table></figure><p>这里是使用<code>createAction</code>的地方，将这个函数的返回对象传递给<code>dispatch</code>方法，然后他会在应用程序中传递给<code>reducer</code>，在典型的<code>React</code>应用程序中，通常不会直接使用<code>getState</code>，<code>subscribe</code>因为有一个帮助函数(因为在 React 中有一个 react-redux 这个包提供了两个 API 帮助我们更好的使用 redux，而上面这两个函数是用在其他框架中使用 redux 提供的基础 API，用起来还是比较麻烦的)，将组件和状态链接到一起，而<code>replaceReducer</code>是一种先进的 API 它用来替换<code>reducer</code>函数，我没用过这个函数</p><h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><p><code>reducer</code>可能是<code>Redux</code>中最为精妙的部分，<code>reducer</code>有两个特点非常重要：</p><ul><li>它必须是纯函数，意味着只要输入相同，那么输出一定相同。</li><li>它不应该有副作用，像访问全局变量，进行异步操作等</li></ul><p>下面是一个简单的计数器的<code>reducer</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counterReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 接受另个参数，第一个参数是当前状态，第二个参数是action对象，其中必定包含了type属性，也可以附带其他的数据</span></span><br><span class="line">  <span class="keyword">if</span> (action.type === ADD) &#123;</span><br><span class="line">    <span class="comment">// 对比type 是否等一 “ADD”</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: state.value + <span class="number">1</span> &#125;; <span class="comment">// 是则+1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === SUBTRACT) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: state.value - <span class="number">1</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;; <span class="comment">// 如果type都不符则返回value：0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个函数没有副作用，而且每次都会返回一个全新的对象，根据之前的值进行累加或者减少</p><h2 id="连接到-React-组件"><a href="#连接到-React-组件" class="headerlink" title="连接到 React 组件"></a>连接到 React 组件</h2><p>如果是在<code>React</code>中讨论<code>redux</code>那么必定包含<code>react-redux</code>模块，<code>react-redux</code>提供了两个重要 API 用来将 React 和 Redux 进行连接</p><ol><li><p><code>&lt;Provider/&gt;</code> 组件，他是一个组件，接受一个<code>Store</code>作为参数，并且通过<code>React</code>的 <code>context</code> API 穿透组件进行通信，举个例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"><span class="keyword">import</span> myStore <span class="keyword">from</span> <span class="string">"自己写的store对象"</span>;</span><br><span class="line"><span class="comment">// Provider 应作为最上级组件包裹整个 React 应用，保证他的所有子集都可以获得到传递的数据</span></span><br><span class="line">&lt;Provider store=&#123;myStore&#125;&gt;</span><br><span class="line">  &lt;MyApp /&gt;</span><br><span class="line">&lt;<span class="regexp">/Provider&gt;;</span></span><br></pre></td></tr></table></figure></li><li><p><code>connect</code> 函数，用于订阅<code>Redux</code>的<code>Store</code>并且用来更新 UI ，他是一个高阶组件，下面是它接受的参数</p></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options]);</span><br></pre></td></tr></table></figure><p>mapStateToProps 参数是是一个函数，它会接受到当前的<code>state</code>作为参数，并且必须返回一个对象，这些对象会被以<code>props</code>的形式传递给组件，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">  visible: state.visible</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这样组件将会接收到一个 visible 的 props 他的值就是 store里面的 visible</span></span><br></pre></td></tr></table></figure><p>mapDispatchToProps 也是一个函数，但不是接受<code>state</code>而是接受<code>dispatch</code>作为参数，这里可以定义<code>dispatch action</code>props 的地方</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> (&#123;</span><br><span class="line">  changeVisibility: <span class="function"><span class="params">value</span> =&gt;</span> dispatch(changeVisibility(value))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这样组件将会接受到一个 changeVisibility 函数的 props 运行这个函数并且传入一个参数就会dispatch一个action</span></span><br></pre></td></tr></table></figure><p>​</p><p>后面最后两个参数用的比较少，可以去官方文档看。</p><h2 id="一个简单的计数器"><a href="#一个简单的计数器" class="headerlink" title="一个简单的计数器"></a>一个简单的计数器</h2><p>来创建一个简单的应用来使用上面提到的 API</p><p><a href="https://codesandbox.io/s/qxnl7wxylq" target="_blank" rel="noopener">这里写了个在线的例子，可以跑起来的</a></p><h3 id="创建-action"><a href="#创建-action" class="headerlink" title="创建 action"></a>创建 action</h3><p>对于作者而言，每个<code>Redux</code>都应该从构建<code>action</code>开始，并且定义我们向保留的状态，对于计数器而言，设计三个状态<code>ADD</code>增加，<code>subtract</code>减少，<code>change visibility</code>更改计数器数值</p><h3 id="Store-和-reducer"><a href="#Store-和-reducer" class="headerlink" title="Store 和 reducer"></a>Store 和 reducer</h3><p>有些东西在前面没讲到，是说一个应用通常有很多个<code>reducer</code>，这样可以分开定义很多事情，而不必耦合在一起，这里的<code>Store</code>虽然只有一个，但是可以有很多属性，就是下面这种结构</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 但是redux提供了组合函数将这些分片的reduce组合起来</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, combineReducers &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</span><br><span class="line">  counter: reducer1,</span><br><span class="line">  visible: reducer2</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer);</span><br></pre></td></tr></table></figure><p>接下来定义<code>reducer</code>应该定义的<code>ADD</code>,<code>SUBRECT</code>并且计算出新的<code>counter</code>状态</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为比较少所以就用了if 如果多的话可以使用 swift 进行匹配</span></span><br><span class="line"><span class="keyword">const</span> counterReducer = <span class="function"><span class="keyword">function</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === ADD) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: state.value + <span class="number">1</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === SUBTRACT) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: state.value - <span class="number">1</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state || &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>Redux</code>初始化的时候，每个<code>reducer</code>会被至少触发一次，在第一次运行的时候<code>state</code>是<code>undefined</code>和<code>action</code>现在<code>{ type: &quot;@@redux/INIT&quot;}</code>， 之后我们定义的<code>reducer</code>就会返回数据的初始值<code>{ value: 0 }</code></p><p>之后的第三个也就是<code>CHANGE_VISIBILITY</code>也和上面的差不多</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visibilityReducer = <span class="function"><span class="keyword">function</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === CHANGE_VISIBILITY) &#123;</span><br><span class="line">    <span class="keyword">return</span> action.visible;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样我们就有了两个<code>reducer</code>，就可以按照上面的方法将这两个<code>reducer</code>组合起来</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</span><br><span class="line">  counter: counterReducer,</span><br><span class="line">  visible: visibilityReducer</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h3><p>首先处理计数器的用户界面</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Visibility</span>(<span class="params">&#123; changeVisibility &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; changeVisibility(<span class="literal">true</span>)&#125;&gt;Visible&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; changeVisibility(false)&#125;&gt;Hidden&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const VisibilityConnected = connect(</span></span><br><span class="line"><span class="regexp">  null, /</span><span class="regexp">/ 没有订阅任何的 Store 的属性</span></span><br><span class="line"><span class="regexp">  dispatch =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 被映射到 props 的方法</span></span><br><span class="line"><span class="regexp">    changeVisibility: value =&gt; dispatch(changeVisibility(value))</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp">)(Visibility); /</span><span class="regexp">/ 高阶组件的用法</span></span><br></pre></td></tr></table></figure><p>第二个组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123; value, add, subtract &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Value: &#123;value&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;add&#125;&gt;Add&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;subtract&#125;&gt;Subtract&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CounterConnected = connect(</span><br><span class="line">  state =&gt; (&#123;</span><br><span class="line">    <span class="comment">// 订阅了</span></span><br><span class="line">    value: state.counter.value</span><br><span class="line">  &#125;),</span><br><span class="line">  dispatch =&gt; (&#123;</span><br><span class="line">    add: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(add()),</span><br><span class="line">    subtract: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(subtract())</span><br><span class="line">  &#125;)</span><br><span class="line">)(Counter);</span><br></pre></td></tr></table></figure><p>最后的组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">&#123; visible &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;VisibilityConnected /&gt;</span><br><span class="line">      &#123; visible &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">CounterConnected</span> /&gt;</span></span> &#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const AppConnected = connect(</span></span><br><span class="line"><span class="regexp">  state =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">    visible: state.visible;</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp">)(App);</span></span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-tags"><a href="/tags/React/" rel="tag"># React</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/04/21/Docker学习笔记/" rel="next" title="Docker学习笔记"><i class="fa fa-chevron-left"></i> Docker学习笔记</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2018/07/22/Immer源码学习/" rel="prev" title="Immer源码学习">Immer源码学习<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">H</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">51</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">24</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/HiMrHu" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#通讯"><span class="nav-number">1.</span> <span class="nav-text">通讯</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#输入"><span class="nav-number">1.1.</span> <span class="nav-text">输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输出"><span class="nav-number">1.2.</span> <span class="nav-text">输出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事件处理"><span class="nav-number">2.</span> <span class="nav-text">事件处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组合"><span class="nav-number">3.</span> <span class="nav-text">组合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-React-的-children-API"><span class="nav-number">3.1.</span> <span class="nav-text">使用 React 的 children API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传递一个子组件作为-Porps"><span class="nav-number">3.2.</span> <span class="nav-text">传递一个子组件作为 Porps</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#高阶组件"><span class="nav-number">4.</span> <span class="nav-text">高阶组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#render-props"><span class="nav-number">4.1.</span> <span class="nav-text">render props</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#受控组件和非受控组件"><span class="nav-number">5.</span> <span class="nav-text">受控组件和非受控组件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#展示组件和容器组件"><span class="nav-number">6.</span> <span class="nav-text">展示组件和容器组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题"><span class="nav-number">6.1.</span> <span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#提取容器组件"><span class="nav-number">6.1.1.</span> <span class="nav-text">提取容器组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#展示组件"><span class="nav-number">6.1.2.</span> <span class="nav-text">展示组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#这样做的好处"><span class="nav-number">6.1.3.</span> <span class="nav-text">这样做的好处</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#单向数据流"><span class="nav-number">7.</span> <span class="nav-text">单向数据流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Flux"><span class="nav-number">8.</span> <span class="nav-text">Flux</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatcher"><span class="nav-number">8.1.</span> <span class="nav-text">dispatcher</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更新-View-和-Store"><span class="nav-number">8.2.</span> <span class="nav-text">更新 View 和 Store</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-Flux-辅助函数"><span class="nav-number">8.2.1.</span> <span class="nav-text">使用 Flux 辅助函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-context"><span class="nav-number">8.2.2.</span> <span class="nav-text">使用 context</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高阶组件概念"><span class="nav-number">8.2.3.</span> <span class="nav-text">高阶组件概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作者的选择"><span class="nav-number">8.2.4.</span> <span class="nav-text">作者的选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#action"><span class="nav-number">8.2.5.</span> <span class="nav-text">action</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redux"><span class="nav-number">9.</span> <span class="nav-text">Redux</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Actions"><span class="nav-number">9.1.</span> <span class="nav-text">Actions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Store"><span class="nav-number">9.2.</span> <span class="nav-text">Store</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reducer"><span class="nav-number">9.3.</span> <span class="nav-text">Reducer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连接到-React-组件"><span class="nav-number">9.4.</span> <span class="nav-text">连接到 React 组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个简单的计数器"><span class="nav-number">9.5.</span> <span class="nav-text">一个简单的计数器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建-action"><span class="nav-number">9.5.1.</span> <span class="nav-text">创建 action</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Store-和-reducer"><span class="nav-number">9.5.2.</span> <span class="nav-text">Store 和 reducer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-组件"><span class="nav-number">9.5.3.</span> <span class="nav-text">React 组件</span></a></li></ol></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">H</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html>