<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="python,"><meta name="description" content="python 中的正则表达式"><meta name="keywords" content="python"><meta property="og:type" content="article"><meta property="og:title" content="python正则表达式"><meta property="og:url" content="https://github.com/HiMrHu/H.git/2018/08/12/python正则表达式/index.html"><meta property="og:site_name" content="胡先生"><meta property="og:description" content="python 中的正则表达式"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2020-05-04T05:06:36.935Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="python正则表达式"><meta name="twitter:description" content="python 中的正则表达式"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://github.com/HiMrHu/H.git/2018/08/12/python正则表达式/"><title>python正则表达式 | 胡先生</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">胡先生</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://github.com/HiMrHu/H.git/2018/08/12/python正则表达式/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="H"><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="胡先生"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">python正则表达式</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-12T20:43:27+00:00">2018-08-12</time></span></div></header><div class="post-body" itemprop="articleBody"><p>python 中的正则表达式</p><a id="more"></a><h1 id="正则表达式用来匹配字符串中特定的字符"><a href="#正则表达式用来匹配字符串中特定的字符" class="headerlink" title="正则表达式用来匹配字符串中特定的字符"></a>正则表达式用来匹配字符串中特定的字符</h1><p>正则表达式简称 regex<br>例如\d 是一个正则表达式,表示以为数字字符,即任何一位 0-9 的数字.</p><h2 id="python-中的所有表达式的函数都在-re-模块中例如"><a href="#python-中的所有表达式的函数都在-re-模块中例如" class="headerlink" title="python 中的所有表达式的函数都在 re 模块中例如"></a>python 中的所有表达式的函数都在 re 模块中例如</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">phonNumRegex = re.compile(<span class="string">r'\d\d\d-\d\d\d-\d\d\d\d'</span>)</span><br></pre></td></tr></table></figure><h1 id="匹配-regex-对象"><a href="#匹配-regex-对象" class="headerlink" title="匹配 regex 对象"></a>匹配 regex 对象</h1><p>regex 对象的 search 方法传入要查找的字符串,寻找该正则表达式的所有匹配,如果<br>没有找到则返回 none,如果找到了该模式,search 方法返回一个 match 对象,match 对象,有一个 group 方法,他返回被查找字符串中实际匹配的文本</p><p>mo = phonNumRegex.search(‘my number is 455-333-1234’)<br>print(f’phone number is: {mo.group()}’)</p><p>在 python 中使用正则表达式有几个步骤:<br>使用 import re 导入模块<br>使用 re.complile 函数方法创建一个 regex 对象<br>想 regex 对象的 search 方法传入想要查找的字符串,他返回一个 match 对象<br>调用 match 对象的 group 方法,返回实际匹配文本的字符串</p><h2 id="用正则表达式匹配更多模式"><a href="#用正则表达式匹配更多模式" class="headerlink" title="用正则表达式匹配更多模式"></a>用正则表达式匹配更多模式</h2><h3 id="利用括号分组"><a href="#利用括号分组" class="headerlink" title="利用括号分组"></a>利用括号分组</h3><p>假定想要将区号从电话号码中分离,添加括号将在正则表达式中分组:(\d\d\d)-(\d\d\d-\d\d\d),然后使用 group 匹配对象方法,冲分组中获取匹配的文本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">phonNumRegex = re.compile(<span class="string">r'(\d\d\d)-(\d\d\d-\d\d\d\d)'</span>)</span><br><span class="line"></span><br><span class="line">mo = phonNumRegex.search(<span class="string">'my phone is 444-111-3123'</span>)</span><br><span class="line">print(mo.group(<span class="number">1</span>))  <span class="comment"># 获得区号</span></span><br><span class="line">print(mo.group(<span class="number">2</span>))  <span class="comment"># 获得电话号码</span></span><br></pre></td></tr></table></figure><h3 id="如果一次性要获得所有分组需要调用-groups"><a href="#如果一次性要获得所有分组需要调用-groups" class="headerlink" title="如果一次性要获得所有分组需要调用 groups()"></a>如果一次性要获得所有分组需要调用 groups()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">print(mo.groups())   <span class="comment"># 获得所有分组结果为元组</span></span><br></pre></td></tr></table></figure><p>利用管道匹配多个分组字符|称为管道,希望匹配许多表达式中的一个时,就可以使它,例如 r’Batman|Tina Fey’ 将匹配’Batman’ 或 ‘Tina Fey’</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">heroRegex = re.compile(<span class="string">r'Batman|Tian Fay'</span>)</span><br><span class="line">mo1 = heroRegex.search(<span class="string">'Batman and Tina Fay'</span>)</span><br><span class="line">print(mo1.group())</span><br><span class="line"></span><br><span class="line">mo2 = heroRegex.search(<span class="string">'Tian fey and Batman'</span>)</span><br><span class="line">print(mo2.group())</span><br></pre></td></tr></table></figure><p>利用 findall 方法可以找到所有匹配的方法,后面会讲 print(‘_’ _ 32)使用问好实现可选匹配有时候匹配的模式是可选的,也就是说无论这段文本在不在,正则表达式都会认为匹配字符?标识他前面的分组在这个模式中是可选的,例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">batRegex = re.compile(<span class="string">r'Bat(wo)?man'</span>)</span><br><span class="line"></span><br><span class="line">mo1 = batRegex.search(<span class="string">'the adventures of Batman'</span>)</span><br><span class="line">print(mo1.group())</span><br><span class="line"></span><br><span class="line">mo2 = batRegex.search(<span class="string">'the adventures of Batwoman'</span>)</span><br><span class="line">print(mo2.group())</span><br></pre></td></tr></table></figure><h3 id="使用星号进行-0-次或者多次的匹配"><a href="#使用星号进行-0-次或者多次的匹配" class="headerlink" title="使用星号进行 0 次或者多次的匹配"></a>使用星号进行 0 次或者多次的匹配</h3><p><em>意味着要进行 0 次或者多次的匹配,即在</em>之前进行分组,可以在文本中出现任意次数<br>也可以完全不存在,或一次又一次的重复例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">batRegex = re.compile(<span class="string">r'Bat(wo)*man'</span>)</span><br><span class="line"></span><br><span class="line">mo1 = batRegex.search(<span class="string">'the adnentures of Batman'</span>)</span><br><span class="line"></span><br><span class="line">print(mo1.group())</span><br><span class="line"></span><br><span class="line">mo2 = batRegex.search(<span class="string">'the adnentures of Batwowowowowowoman'</span>)</span><br></pre></td></tr></table></figure><h3 id="使用加号匹配一次或者多次"><a href="#使用加号匹配一次或者多次" class="headerlink" title="使用加号匹配一次或者多次"></a>使用加号匹配一次或者多次</h3><ul><li>意味着匹配 0 次或者多次,+则意味着匹配一次或者多次,星号不要求分组出现在匹配<br>的字符串中,但是加号不同,加号前面的分组必须’至少出现一次’</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">batRegex = re.compile(<span class="string">r'Bat(wo)+man'</span>)</span><br><span class="line"></span><br><span class="line">mo1 = batRegex.search(<span class="string">'the adventures of Batwoman'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果wo一次也没有出现那么会报错</span></span><br><span class="line">print(mo1.group())</span><br></pre></td></tr></table></figure><h3 id="使用花括号匹配特定次数"><a href="#使用花括号匹配特定次数" class="headerlink" title="使用花括号匹配特定次数"></a>使用花括号匹配特定次数</h3><p>如果想要一个分组特定次数,就在正则表达式中改分组的后面,跟上花括号包裹的数字<br>例如正则表达式的(Ha){3}将匹配字符串’HaHaHa’,但不会匹配’HaHa’因为后者字符串只出现了两次除了一个数字,还可以指定一个范围,即在花括号中写下一个最小值,一个逗号一个最大值例如(Ha){1,3} 将匹配’HaHaHa’ ‘HaHa’ ‘Ha’,也可以不写花括号中的第一个或者第二个数字,不限定最小值和最大值例如(ha){3,}将匹配三次和更多次数,(ha){,5}将匹配 0 到 5 次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">haRegex = re.compile(<span class="string">r'(ha)&#123;3&#125;'</span>)</span><br><span class="line">mo = haRegex.search(<span class="string">'hahaha'</span>)</span><br><span class="line"></span><br><span class="line">print(mo.group())</span><br><span class="line"></span><br><span class="line">mo1 = haRegex.search(<span class="string">'ha'</span>)</span><br><span class="line">print(mo1 == <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><h3 id="贪心匹配和非贪心匹配"><a href="#贪心匹配和非贪心匹配" class="headerlink" title="贪心匹配和非贪心匹配"></a>贪心匹配和非贪心匹配</h3><p>在字符串’hahaha’中因为(ha){1,3}可以匹配 1,2,3 个实例,那么为什么字符串<br>‘hahaha’的 Match 对象调用 group()方法会返回’hahaha’而不是’ha’之类的比较短的结果因为 python 的正则表达式默认是匹配更多的即’贪心’的,这表示在二意的情况去,它会尽可能的匹配最长的字符串,而花括号的非贪心版本匹配尽可能短的字符串,即在结束的花括号后跟着一个问好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">greedyHaRegex = re.compile(<span class="string">r'(ha)&#123;3,5&#125;?'</span>)</span><br><span class="line"></span><br><span class="line">mo = greedyHaRegex.search(<span class="string">'hahahahaha'</span>)</span><br><span class="line"></span><br><span class="line">print(mo.group())</span><br></pre></td></tr></table></figure><h3 id="findall-方法"><a href="#findall-方法" class="headerlink" title="findall()方法"></a>findall()方法</h3><p>除了 search 方法之外 Regex 对象还有一个 findall 方法,search 方法将返回一个 Match 对象包含被查找字符串中第一次匹配的的文本,而 findall 方法将返回一组字符串,包含被查找字符串中的所有匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">phonNumRegex = re.compile(<span class="string">r'\d\d\d-\d\d\d-\d\d\d\d'</span>)</span><br><span class="line"></span><br><span class="line">mo = phonNumRegex.search(<span class="string">'call: 515-222-1234 work: 121-333-1231'</span>)</span><br><span class="line">print(mo.group())</span><br></pre></td></tr></table></figure><h3 id="findall-方法返回一个列表"><a href="#findall-方法返回一个列表" class="headerlink" title="findall 方法返回一个列表"></a>findall 方法返回一个列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(phonNumRegex.findall(<span class="string">'call: 515-222-1234 work: 121-333-1231'</span>))</span><br></pre></td></tr></table></figure><ul><li>字符分类</li><li>\d 0-9 的任何数字</li><li>\D 除了 0-9 之外的任意字符</li><li>\w 任何字母,数字或下划线(可以认为是匹配’单词’字符)</li><li>\W 除了字母,数字和下划线以外的任何字符</li><li>\s 空格,制表符或换行符(可以认为匹配’空白’字符)</li><li>\S 除了空格制表符或者换行符以外的任何字符</li></ul><p>字符分类对于缩短正则表达式很有用,字符分类[0-5]只匹配数字 0-5</p><h3 id="插入字符"><a href="#插入字符" class="headerlink" title="插入字符"></a>插入字符</h3><p>可以在正则表达式的开始处使用插入符号^,标明匹配必须发生在被查找文本的开始处类似的,可以在正则表达式的末尾加上$,表示该字符串必须以这个正则表达式的模式结束可以同时使用^和$</p><p>例如使用 r’Hello’匹配以’Hello’开始的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beginsWithHello = re.compile(<span class="string">r'^hello'</span>)</span><br><span class="line"></span><br><span class="line">mo = beginsWithHello.search(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line">print(mo.group())</span><br></pre></td></tr></table></figure><p>beginsWithHello.search(‘he said hello’) 这条是无法匹配的</p><h3 id="正则表达式-r’-d-‘匹配以数字-0-9-结束的字符串"><a href="#正则表达式-r’-d-‘匹配以数字-0-9-结束的字符串" class="headerlink" title="正则表达式 r’\d$‘匹配以数字 0-9 结束的字符串"></a>正则表达式 r’\d$‘匹配以数字 0-9 结束的字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">endsWithNumber = re.compile(<span class="string">r'\d$'</span>)</span><br><span class="line"></span><br><span class="line">print(endsWithNumber.search(<span class="string">'you number is 43'</span>).group())</span><br></pre></td></tr></table></figure><h3 id="正则表达-r’-d-‘表示匹配数字开头和结尾的字符串"><a href="#正则表达-r’-d-‘表示匹配数字开头和结尾的字符串" class="headerlink" title="正则表达 r’\d+$‘表示匹配数字开头和结尾的字符串"></a>正则表达 r’\d+$‘表示匹配数字开头和结尾的字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wholeStringIsNum = re.compile(<span class="string">r'\d+$'</span>)</span><br><span class="line"></span><br><span class="line">print(wholeStringIsNum.search(<span class="string">'3 is 33'</span>).group())</span><br></pre></td></tr></table></figure><h3 id="通配字符"><a href="#通配字符" class="headerlink" title="通配字符"></a>通配字符</h3><p>在正则表达式中 . 字符被称为”通配符”,它匹配除了换行之外的所有字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atRegex = re.compile(<span class="string">f'.at'</span>)</span><br><span class="line"></span><br><span class="line">print(atRegex.findall(<span class="string">'the can in the hat sat on the flat mat'</span>))</span><br></pre></td></tr></table></figure><p>.at 只匹配一个字符这也就是上面的 flat 只匹配到 flat</p><h3 id="用-匹配所有字符"><a href="#用-匹配所有字符" class="headerlink" title="用.* 匹配所有字符"></a>用.* 匹配所有字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nameRegex = re.compile(<span class="string">f'First Name:(.*) Last Name:(.*)'</span>)</span><br><span class="line"></span><br><span class="line">print(nameRegex.search(<span class="string">'First Name: AL Last Name: Sweigart'</span>).group())</span><br></pre></td></tr></table></figure><h3 id="用句点字符匹配换行"><a href="#用句点字符匹配换行" class="headerlink" title="用句点字符匹配换行"></a>用句点字符匹配换行</h3><p>.*将匹配除了换行之外的所有字符,通过传入 re.DOTALL 作为 re.compole 的第二个参数<br>可以让.匹配所有字符,包括换行符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">noNewLineRegx = re.compile(<span class="string">'.*'</span>, re.DOTALL)</span><br><span class="line">print(noNewLineRegx.search(<span class="string">'serve the public trust .\n Protect the innocent'</span>).group())</span><br></pre></td></tr></table></figure><p>正则表达式符号复现</p><ul><li>?匹配零次或者一次前面的分组</li><li>*匹配零次或者多次前面的分组</li><li>+匹配一次或者多次前面的分组</li><li>{n}匹配 n 次前面的分组</li><li>{n,}匹配 n 次到多次前面的分组</li><li>{,m} 匹配零次到 m 次前面的分组</li><li>{n,m}匹配至少 n 次,至多 m 次前面的分组</li><li>{n,m}?或*?或+?对前面的分组都是进行非贪心算法</li><li>^spam 意味着字符串必须与 spam 开始</li><li>spam$ 意味着字符串必须与 spam 结尾</li><li>.匹配所有字符,除了换行符</li><li>\d,\w,\s 分别匹配数字单词和空格</li><li>\D,\W,\S 分别匹配出数字,单词和空格外的所有字符</li><li>[abc]匹配方括号内的任意字符</li><li>[^abc]匹配不在方括号内的任意字符</li></ul><h3 id="不区分大小写"><a href="#不区分大小写" class="headerlink" title="不区分大小写"></a>不区分大小写</h3><p>不区分大小写可以向 compile 传入第二个参数 re.I 或者 re.IGNORECASE</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pobocop = re.compile(<span class="string">r'robocop'</span>, re.I)</span><br><span class="line"></span><br><span class="line">print(pobocop.search(<span class="string">'RoboCop is ...'</span>).group())</span><br></pre></td></tr></table></figure><h3 id="使用-sub-方法替换字符串"><a href="#使用-sub-方法替换字符串" class="headerlink" title="使用 sub 方法替换字符串"></a>使用 sub 方法替换字符串</h3><p>正则表达式不仅能够找到文本模式,而且能够用新的文本替换掉这些模式,Regex 对象的 sub 方法需要传入两个参数,第一个是字符串,用于取代发现的匹配,第二个参数是一个字符串,用于正则表达式匹配的内容,返回替换完成的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nameRegex = re.compile(<span class="string">r'Agent \w+'</span>)</span><br><span class="line"></span><br><span class="line">print(nameRegex.sub(<span class="string">'GENSORED'</span>, <span class="string">'Agent Alice gave the secret document to Agent Bob'</span>))</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-tags"><a href="/tags/python/" rel="tag"># python</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/07/22/Immer源码学习/" rel="next" title="Immer源码学习"><i class="fa fa-chevron-left"></i> Immer源码学习</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2018/08/17/HTTP/" rel="prev" title="HTTP">HTTP<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">H</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">51</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">24</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/HiMrHu" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#正则表达式用来匹配字符串中特定的字符"><span class="nav-number">1.</span> <span class="nav-text">正则表达式用来匹配字符串中特定的字符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#python-中的所有表达式的函数都在-re-模块中例如"><span class="nav-number">1.1.</span> <span class="nav-text">python 中的所有表达式的函数都在 re 模块中例如</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#匹配-regex-对象"><span class="nav-number">2.</span> <span class="nav-text">匹配 regex 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用正则表达式匹配更多模式"><span class="nav-number">2.1.</span> <span class="nav-text">用正则表达式匹配更多模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#利用括号分组"><span class="nav-number">2.1.1.</span> <span class="nav-text">利用括号分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果一次性要获得所有分组需要调用-groups"><span class="nav-number">2.1.2.</span> <span class="nav-text">如果一次性要获得所有分组需要调用 groups()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用星号进行-0-次或者多次的匹配"><span class="nav-number">2.1.3.</span> <span class="nav-text">使用星号进行 0 次或者多次的匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用加号匹配一次或者多次"><span class="nav-number">2.1.4.</span> <span class="nav-text">使用加号匹配一次或者多次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用花括号匹配特定次数"><span class="nav-number">2.1.5.</span> <span class="nav-text">使用花括号匹配特定次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#贪心匹配和非贪心匹配"><span class="nav-number">2.1.6.</span> <span class="nav-text">贪心匹配和非贪心匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#findall-方法"><span class="nav-number">2.1.7.</span> <span class="nav-text">findall()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#findall-方法返回一个列表"><span class="nav-number">2.1.8.</span> <span class="nav-text">findall 方法返回一个列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入字符"><span class="nav-number">2.1.9.</span> <span class="nav-text">插入字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正则表达式-r’-d-‘匹配以数字-0-9-结束的字符串"><span class="nav-number">2.1.10.</span> <span class="nav-text">正则表达式 r’\d$‘匹配以数字 0-9 结束的字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正则表达-r’-d-‘表示匹配数字开头和结尾的字符串"><span class="nav-number">2.1.11.</span> <span class="nav-text">正则表达 r’\d+$‘表示匹配数字开头和结尾的字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通配字符"><span class="nav-number">2.1.12.</span> <span class="nav-text">通配字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用-匹配所有字符"><span class="nav-number">2.1.13.</span> <span class="nav-text">用.* 匹配所有字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用句点字符匹配换行"><span class="nav-number">2.1.14.</span> <span class="nav-text">用句点字符匹配换行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不区分大小写"><span class="nav-number">2.1.15.</span> <span class="nav-text">不区分大小写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-sub-方法替换字符串"><span class="nav-number">2.1.16.</span> <span class="nav-text">使用 sub 方法替换字符串</span></a></li></ol></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">H</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html>